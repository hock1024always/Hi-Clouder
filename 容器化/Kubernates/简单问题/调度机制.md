# 1. 简述 Kubernetes Pod 的常见调度方式？

**思路**：

从“默认自动调度”出发，再列举人工干预和高级策略，体现对调度控制的全面理解。

**回答**：

Kubernetes Pod 的常见调度方式包括：

- **自动调度**：由 kube-scheduler 基于资源请求、节点状态等自动选择最优节点（默认行为）；
- **节点选择器（nodeSelector）**：通过 Pod 的 `spec.nodeSelector` 匹配节点 label，实现简单定向调度；
- **节点亲和性（nodeAffinity）**：支持更复杂的匹配规则（如 `preferredDuringScheduling` 软策略、`requiredDuringScheduling` 强制策略）；
- **Pod 亲和性/反亲和性（podAffinity/podAntiAffinity）**：根据其他 Pod 的位置决定调度（如“同 AZ 部署”或“避免同一节点”）；
- **污点与容忍（Taints & Tolerations）**：节点设置 taint 排斥普通 Pod，只有带对应 toleration 的 Pod 才可调度（常用于专用节点如 GPU 节点）；
- **nodeName 直接指定**：强制将 Pod 绑定到特定节点（绕过调度器，调试用）。

这些机制共同实现灵活、可靠的调度控制。

------

# 2. 简述 Kubernetes Scheduler 作用及实现原理？

**思路**：

先定义角色（调度决策者），再说明其工作流程（watch → filter → score → bind）。

**回答**：

**kube-scheduler** 是 Kubernetes 控制平面的核心组件，负责**为未绑定节点的 Pod 选择最合适的 Worker 节点**。其实现原理基于两阶段调度框架：

1. **过滤（Filtering / Predicates）**：排除不满足 Pod 要求的节点（如资源不足、label 不匹配、taint 无法容忍等）；
2. **打分（Scoring / Priorities）**：对剩余节点按策略评分（如资源均衡、亲和性、拓扑分布），选择得分最高者；
3. 最终通过 API Server 将 Pod 与选定节点绑定（写入 `pod.spec.nodeName`）。
   整个过程通过 watch API Server 实时响应新 Pod，支持插件化扩展（如 Scheduling Framework），实现高效、可定制的调度决策。

------

# 3. 简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 Worker 节点？

**思路**：

明确回答“过滤（Filter）”和“打分（Score）”两大阶段，并说明其目的。

**回答**：

Kubernetes Scheduler 主要使用以下两种算法阶段将 Pod 绑定到 Worker 节点：

1. **过滤算法（Filtering / Predicate）**：
   - 目的：**筛选出所有可运行该 Pod 的候选节点**；
   - 示例：检查节点资源是否充足（CPU/Memory）、是否存在不可容忍的污点、是否满足 nodeSelector 或亲和性硬性要求等；
2. **打分算法（Scoring / Priority）**：
   - 目的：**在候选节点中选出“最优”节点**；
   - 示例：优先选择资源剩余较多的节点（LeastRequested）、与已有 Pod 同拓扑域（TopologySpread）、满足软亲和性偏好等。
     最终，Scheduler 将 Pod 绑定到得分最高的节点，完成调度。

> 注：自 K8s v1.18 起，调度框架（Scheduling Framework）允许用户通过插件自定义这两个阶段的行为。