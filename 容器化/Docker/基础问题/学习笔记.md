# docker

## What：什么是docker？什么是容器镜像？什么是容器？

1. **Docker**：Docker是一种开源的容器化平台，用于构建、分享和运行应用程序。它通过将应用程序及其所有依赖项打包到一个轻量级、可移植的容器中，实现了应用程序与底层操作系统的解耦。
2. **Image**：Docker**容器镜像**指的是正在运行的容器所使用的隔离文件系统**。**这个隔离的文件系统由容器镜像提供，而容器镜像必须包含运行应用程序所需的所有内容，包括所有依赖项、配置、脚本、二进制文件等。此外，镜像还包含容器的其他配置，例如环境变量、默认的运行命令以及其他元数据。
3. **Container：**Docker容器是在容器镜像的基础上创建的**。**容器内部空间是与外界隔离的环境，该空间内使用的系统即为linux系统(根文件系统)，容器内部直接使用 root 用户进行操作。容器内部的环境资源由Docker容器镜像提供。

## Why：为什么我们需要使用docker

这里结合**一个场景来进行说明**：假设在连接到了一台新的Linux虚拟机上，需要运行python相关的代码，比如说使用python部署一个简单的Flask服务，但该虚拟机上缺少python的运行环境，该怎么解决？

当然可以通过 apt 包去配置虚拟机的python运行环境，但是使用docker工具去配置会更加便利：

1. 使用 docker 可以拉取开源平台上的 python 镜像，这个镜像包含的 python 运行的相关环境。
2. 使用 python 镜像创建容器，进入到容器内部，其内部的系统可以理解为小型的linux系统
3. 在容器内部，可以使用 pip 安装 python 库，并且运行 python 代码，部署 Flask 服务
4. 而对于这台新Linux虚拟机，其仍然不具备直接运行python的环境。换言之，容器内部的环境是一种虚拟环境，其内部相关操作不会直接影响宿主机的环境。
5. Docker可以让容器挂起执行，Docker 会通过端口映射向容器外界提供 Flask 服务
6. 对于docker容器的管理，当我们不在需要这个Flask服务，可以使用Docker直接删除容器，想要再次使用时，再用python镜像重新创建容器即可

由此可见，Docker工具可以实现环境的快速搭建，同时其镜像和容器管理功能能够更方便的管理各个服务与其对应的环境，而不会使自己虚拟机上的环境一团糟。

更多理由，这里简单的了解即可：

- 安全性与隔离性
- 跨平台支持
- 易于版本控制和回滚
- 易于扩展和伸缩
- 资源利用率高。

## What：什么是DockerFile？

Dockerfile 是一个静态的文本文件，可以简单理解为脚本，其中按照顺序记录了构建特定镜像所需的所有指令，**Docker引擎通过解析Dockerfile中的指令来自动化构建镜像**。这种自动化构建的方式使得镜像的创建过程变得可重复和可靠

在Dockerfile中，可以指定所需的基础镜像、安装软件包、拷贝文件、设置环境变量等等。**每个****指令****都会在前一个指令的基础上进行构建，最终形成一个完整的镜像**。**通过编写清晰的Dockerfile，可以定义和管理镜像的构建过程**，确保镜像可以在不同的环境中正确地部署和运行。

当运行 `docker build`命令时，Docker会读取并执行Dockerfile中的指令，并将其转化为一个镜像。**这个镜像可以用来创建和运行多个相同配置的容器实例**。因此，Dockerfile提供了一种标准化和可重复的方式来构建容器化应用程序的环境。

## How：Docker的基本操作命令

### **镜像拉取与管理**

1. **拉取镜像**  
   1.  从 Docker Hub 下载最新版 Nginx 镜像。
   2. `docker pull nginx:latest`
2. **搜索镜像**  
   1.  在 Docker Hub 搜索与 Redis 相关的镜像。
   2. `docker search redis`
3. **列出本地镜像**  
   1.  显示本地已下载的镜像列表。
   2. `docker images`
4. **删除镜像**  
   1.  删除本地的指定镜像（需先删除依赖容器）。
   2. `docker rmi nginx:latest`

### **容器创建与运行**

1. **创建并启动容器**  
   1. `-d`后台运行
   2. `--name`指定容器名称
   3. `-p` 映射主机端口到容器端口。示例中将容器8080端口映射到主机80端口，用户访问80端口时，docker会自动转发到容器的8080端口，并且自动转发其响应。

```Bash
docker run -d --name my_nginx -p 80:8080 nginx
```

1. **启动已停止的容器**  
   1. `docker start my_nginx`
   2.  启动名为 `my_nginx` 的容器。
2. **停止运行中的容器**  
   1.  优雅停止指定容器。
   2. `docker stop my_nginx`
3. **强制停止容器**  
   1.  强制立即终止容器进程。
   2. `docker kill my_nginx`

### **容器管理**

1. **列出运行中的容器**  
   1.  查看当前运行的容器（加 `-a` 显示所有容器，包括已停止的）。
   2. `docker ps`

1. **查看容器日志**  
   1.  输出容器的日志信息（加 `-f` 实时跟踪日志）。
   2. `docker logs my_nginx`

1. **进入容器终端**  
   1.  交互式进入正在运行的容器内部（`-it` 分配伪终端）。在容器内部使用root用户来操作。
   2. `docker exec -it my_nginx /bin/bash`

1. **删除容器**  
   1.  删除已停止的容器（加 `-f` 强制删除运行中的容器）。
   2. `docker rm my_nginx`

### **网络与数据卷**

1. **创建数据卷**  
   1.  创建一个名为 `my_volume` 的持久化数据卷。
   2. `docker volume create my_volume`

1. **挂载数据卷到容器**  
   1.  将数据卷挂载到容器的 `/app/data` 目录。
   2. `docker run -v my_volume:/app/data nginx`

1. **列出网络**  
   1.  显示所有 Docker 网络。
   2. `docker network ls`

1. **创建自定义网络**  
   1.  创建一个名为 `my_network` 的桥接网络。
   2. `docker network create my_network`

### **其他实用命令**

1. **查看容器资源占用**  
   1.  实时显示容器的 CPU、内存等资源使用情况。
   2. `docker stats`

1. **导出容器为镜像**  
   1.  将当前容器状态保存为新的镜像。
   2. `docker commit my_nginx my_nginx_image`

1. **清理无用资源**  
   1.  删除所有未使用的镜像、容器和网络（加 `-a` 包括未使用的镜像）。
   2. `docker system prune -a`

1. **查看 Docker 信息**  
   1.  显示 Docker 系统信息（版本、存储驱动等）。
   2. `docker info`

## Practice：Docker的简单实践

### 实践环境说明

Docker版本使用最新版即可。Docker安装和Docker镜像源的配置在网上找相关文章跟着做即可，如果拉取不了镜像，一般是镜像源不可使用，需要自己修改配置更换镜像源。

下面是可以使用的镜像源配置。需要配置在文件`/etc/docker/daemon.json`中，若没有`daemon.json`文件，需要手动创建。

```json
{"registry-mirrors": [
    "https://10a65vrf.mirror.aliyuncs.com",
    "https://docker.m.daocloud.io",
    "https://dockerproxy.com",
    "https://docker.mirrors.ustc.edu.cn",
    "https://docker.nju.edu.cn",
    "https://iju8kaj2.mirror.aliyuncs.com",
    "http://hub-mirror.c.163.com",
    "https://cr.console.aliyun.com",
    "https://hub.docker.com",
    "http://mirrors.ustc.edu.cn"
  ]
}
```

### 运行 hello-world镜像

- 拉取hello-world镜像：` docker pull hello-world:latest`
- 运行：`docker run -d --name hello -p 8080:80 hello-world`

### 运行Nginx镜像

- 拉取镜像： `docker pull nginx:latest`
- 运行：`docker run -d -name try-nginx -p 8080:80 nginx`
- 服务器ip地址端口上查看nginx页面 （这里使用的ECS服务器）

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJiNWIwNDM2M2ZkNDA2MzUwYmU3NDAxYjBjZWYwOTBfWmVGbm9xdW1VbDVqczhpd0hlVmpwMXEyYUNvR0x5RW5fVG9rZW46S3JGWWJrM3R0b3VQcWt4S2NxdmNUMkNIbkNNXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

### 创建一个简单的容器

1. 拉取ubuntu镜像： `docker pull ubuntu:latest`
2. 编写dockerfile 和脚本，放在同一个目录下

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU5ZDFhNjZiNTU5MDc3MDE0Mzg5NTA3YWMyZDZkMWJfT0NCMFo5YXh0anBHRjNIaFFMNGhGemNFbVFwVHdSWkNfVG9rZW46TTNIeGJ6enJIb2NKZUl4SksxQWNLcHVGbnliXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

```Dockerfile
# Dockerfile内容
FROM ubuntu:latest

RUN apt-get update && apt-get install -y curl

COPY myscript.sh /myscript.sh

RUN chmod +x /myscript.sh

ENTRYPOINT ["./myscript.sh"]


#  myscript.sh脚本内容

#!/bin/bash
echo "Hello, this is my simple script running in a Dcoker contaner"
```

1. 在当前目录构建镜像：`docker build -t my-container .`
2. 启动镜像：

### 配置Docker 网络

1. 创建自定义网络 ： `docker network create --driver bridge my_network`
2. 启动两个容器 c1 和 c2：
   1. `docker run -itd --name c1 --network my_network ubuntu`
   2. `docker run -itd --name c2 --network my_network ubuntu`

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmJkODQxNWIxYjEzZDAxNDZiZjljZjI1NWYxNTM2NWZfaGJIRTVZd3dOdnlSWExtcE9HSWt0bndjZHN5NzB5T29fVG9rZW46QWpaZmI3ZGZab2p2OFd4QVM0NmM5Sks4bnRiXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

1. 查询c2 ip 地址 ： 
   1.  `docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' c2`
2. 进入c1内部，用ping命令测试网络通信

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=OTk4MDNhNWNmODQ5MzQ5M2U2NjRkYzRhM2VhMGVjMTBfVlNuYXBGeHlFdFlIV2ltdFduWXNZTkJ3RHVlWkVSRGRfVG9rZW46UmFLZWJ3a0RabzVMNk14bE9ybGNZcDl6bkNmXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

### 使用docker volumes 存储数据

1. 拉取MySQL镜像，这里使用5.7版本 `docker pull mysql:5.7`
2. 创建volume 取名sql-data： `docker volume create sql-data`
3. 创建mysql容器，挂载上volume，设定密码

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYwNzk4OGExNzZiYmNiMjM4NDE3ZWVlN2JmZmEwODlfb1dERGVNMkx0WGZIRTJQb1BKVTlZeDdkdnRPVnNCdmdfVG9rZW46WEN5SWJXOUZ0b25QTUN4OE1TZWMyZXNMbk9mXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

1. 进入容器，登录mysql

![img](https://pcnlck7dh76e.feishu.cn/space/api/box/stream/download/asynccode/?code=NTJlOGUzNTAwOGQ0ODg1Njk2NzFjYTNjZWEwOGY2MGVfZUd5NUVPU2RQc0Y4SUhRcUltNG5DeWJvb0lQcU9VdHZfVG9rZW46S0I5SmI2czJTb0lXMFl4RllLSWNEWTIwbnVnXzE3NjkzMzU5Nzg6MTc2OTMzOTU3OF9WNA)

1. 添加数据库test，其中添加一张表 student用作测试
2. 返回宿主主机查看挂载目录，测试是否挂载成功

可以看到test数据库下有一张student表，说明数据成功持久化