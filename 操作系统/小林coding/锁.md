

### 除了互斥锁你还知道什么锁？分别应用于什么场景？

还有读写锁、自旋锁、条件变量、信号量。（进程控制里面线程通信那部分有详细解释）

1. 读写锁：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。适用于读操作频繁、写操作较少的场景，可以提高并发性能。
2. 自旋锁：自旋锁是一种忙等待锁，线程在获取锁时不会进入阻塞状态，而是循环忙等待直到获取到锁。适用于临界区很小且锁的持有时间很短的场景，避免线程频繁切换带来的开销。
3. 条件变量：条件变量用于线程间的同步和通信。它通常与互斥锁一起使用，线程可以通过条件变量等待某个条件满足，当条件满足时，其他线程可以通过条件变量发送信号通知等待线程。
4. 信号量：信号量是一种计数器，用于控制对共享资源的访问。它可以用来限制同时访问资源的线程数量，或者用于线程间的同步。

### 为什么并发执行线程要加锁？

并发执行线程需要加锁主要是为了保护共享数据，防止出现**"竞态条件"**。

"竞态条件"是指当多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，这可能导致数据的不一致性。

通过加锁，我们可以确保在任何时刻只有一个线程能够访问共享数据，从而避免"竞态条件"，确保数据的一致性和完整性。

### 自旋锁是什么？应用在哪些场景？

**自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁。

自旋锁是通过 CPU 提供的 `CAS` 函数（*Compare And Swap*），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：

- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
- 第二步，将锁设置为当前线程持有；

CAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。

使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 `while` 循环等待实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。

自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**

自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。

自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**。

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**

### 死锁发生条件是什么？

死锁只有**同时满足**以下四个条件才会发生：互斥条件--持有并等待（其他资源）--（资源）不可剥夺--环路

- 互斥条件：互斥条件是指**多个线程不能同时使用同一个资源**。
- 持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
- 不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
- 环路等待条件：环路等待条件指的是，在死锁发生的时候，**两个线程获取资源的顺序构成了环形链**。

### 如何避免死锁？

避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。

那什么是资源有序分配法呢？线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

![img](./图片/1719563137049-4306fda2-ca9f-4183-b885-2499eb7570dc.webp)

### 讲一下银行家算法

系统发生死锁是很正常的，我们需要主动去预防死锁，即进行有序的资源分配，使用**银行家算法**。

**银行家算法是最有代表性的避免死锁的算法**。

为什么叫银行家算法呢？就是这个算法的逻辑**很像银行放贷的逻辑，也就是尽可能避免坏账的出现**。

银行家算法的业务逻辑如下。

- **不负荷执行**：一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行。
- **可分期**：一个进程可以分期请求资源，但总请求书不可超过最大需求量。
- **推迟分配**：当系统现有资源数小于进程需求时，对进程的需求可以延迟分配，但总让进程在有限时间内获取资源。

听起来有点绕，我们还是举个例子来说明。

假如系统中有三类互斥资源 R1、R2、R3，可用资源数分别是 9、8、5，在指定时刻有 P1、P2、P3、P4 和 P5 这五个进程，这些进程的对三类互斥资源的最大需求量和已分配资源数如下表所示，那么系统如何先后运行这五个进程，不会发生死锁问题？

| 进程 | 最大需求量（分别为R1 R2 R3） | 已分配资源数（分别为R1 R2 R3） |
| ---- | ---------------------------- | ------------------------------ |
| P1   | 6 5 2                        | 1 2 1                          |
| P2   | 2 2 1                        | 2 1 1                          |
| P3   | 8 1 1                        | 2 1 0                          |
| P4   | 1 2 1                        | 1 2 0                          |
| P5   | 3 4 4                        | 1 1 3                          |

------

第一步：分析

首先分析首次需求的资源，**系统剩余可用资源数分别是 2、1、0**，各进程需要的资源数如下表所示。

资源 R1 的剩余可用资源数 = 9 - 1 - 2 - 2 - 1 - 1 = 2。

资源 R2 的剩余可用资源数 = 8 - 2 - 1 - 1 - 2 - 1 = 1。

资源 R3 的剩余可用资源数 = 5 - 1 - 1 - 0 - 0 - 3 = 0。

| 进程 | 最大需求量 | 已分配资源数 | 首次分配需要的资源数 |
| ---- | ---------- | ------------ | -------------------- |
| P1   | 6 5 2      | 1 2 1        | 5 3 1                |
| P2   | 2 2 1      | 2 1 1        | 0 1 0                |
| P3   | 8 1 1      | 2 1 0        | 6 0 1                |
| P4   | 1 2 1      | 1 2 0        | 0 0 1                |
| P5   | 3 4 4      | 1 1 3        | 2 3 1                |

根据银行家算法**不负荷**原则【一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行】，优先给进程 P2 执行，因为剩余的 0 1 0 资源够让 P2 执行。

第二步：执行 P2

P2 执行之后，释放了刚刚放入的 2 1 0 资源，而且可以释放已分配的 2 1 1 资源，所以此时的资源剩余量。

资源 R1 的剩余可用资源数 = 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 = 2 - 0 +（2 + 0） = 4。

资源 R2 的剩余可用资源数 = 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 = 1 - 1 + （1 + 1） = 2。

资源 R3 的剩余可用资源数 = 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 = 0 - 0 +（0 + 1） = 1。

**执行完成 P2 后，操作系统剩余可用资源数为 4 2 1**。

| 进程 | 最大需求量 | 已分配资源数 | 第二次分配需要的资源数 |
| ---- | ---------- | ------------ | ---------------------- |
| P1   | 6 5 2      | 1 2 1        | 5 3 1                  |
| P2   | 完成       | 完成         | 完成                   |
| P3   | 8 1 1      | 2 1 0        | 6 0 1                  |
| P4   | 1 2 1      | 1 2 0        | 0 0 1                  |
| P5   | 3 4 4      | 1 1 3        | 2 3 1                  |

------

第三步：执行 P4

此时操作系统剩余可用资源数为 4 2 1，只能执行进程 P4，因为其他进程资源不够。

P4 执行之后，释放了刚刚放入的 0 0 1 资源，而且可以释放已分配的 1 2 1 资源，所以此时的资源剩余量。

资源 R1 的剩余可用资源数 = 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 = 4 - 0 +（1 + 0） = 5。

资源 R2 的剩余可用资源数 = 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 = 2 - 0 + （2 + 0） = 4。

资源 R3 的剩余可用资源数 = 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 = 1 - 1 +（0 + 1） = 1。

**执行完成 P4 后，操作系统剩余可用资源数为 5 4 1**。

| 进程 | 最大需求量 | 已分配资源数 | 第三次分配需要的资源数 |
| ---- | ---------- | ------------ | ---------------------- |
| P1   | 6 5 2      | 1 2 1        | 5 3 1                  |
| P2   | 完成       | 完成         | 完成                   |
| P3   | 8 1 1      | 2 1 0        | 6 0 1                  |
| P4   | 完成       | 完成         | 完成                   |
| P5   | 3 4 4      | 1 1 3        | 2 3 1                  |

------

第四步：执行 P5

此时操作系统剩余可用资源数为 5 4 1，只能执行进程 P5，因为其他进程资源不够。

P5 执行之后，释放了刚刚放入的 2 3 1 资源，而且可以释放已分配的 1 1 3 资源，所以此时的资源剩余量。

资源 R1 的剩余可用资源数 = 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 = 5 - 2 +（1 + 2） = 6。

资源 R2 的剩余可用资源数 = 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 = 4 - 3 + （1 + 3） = 5。

资源 R3 的剩余可用资源数 = 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 = 1 - 1 +（3 + 1） = 4。

**执行完成 P5 后，操作系统剩余可用资源数为 6 5 4**。

| 进程 | 最大需求量 | 已分配资源数 | 第三次分配需要的资源数 |
| ---- | ---------- | ------------ | ---------------------- |
| P1   | 6 5 2      | 1 2 1        | 5 3 1                  |
| P2   | 完成       | 完成         | 完成                   |
| P3   | 8 1 1      | 2 1 0        | 6 0 1                  |
| P4   | 完成       | 完成         | 完成                   |
| P5   | 完成       | 完成         | 完成                   |

------

第五步：执行 P1 或者 P3

此时操作系统剩余可用资源数为 6 5 4，可以执行 P1 或 P3。

所以安全执行顺序为 **p2 => p4 => p5 => p1 => p3** 或 **p2 => p4 => p5 => p3 => p1**。

![img](https://cdn.xiaolincoding.com//picgo/1720434387769-ee64c523-a971-46d4-8b59-00aac021b19f.png)

或

![img](https://cdn.xiaolincoding.com//picgo/1720434387791-d1aa6916-6457-41e8-a356-1ebdec1538b0.png)

银行家算法总结

银行家算法的核心思想，就是在**分配给进程资源前，首先判断这个进程的安全性**，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。

**通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列**。安全序列一定不会发生死锁，但没有死锁不一定是安全序列。

### 乐观锁和悲观锁有什么区别？

乐观锁：

- 基本思想：乐观锁假设多个事务之间**很少发生冲突**，因此在读取数据时不会加锁，而是在**更新数据时检查数据的版本**（如使用版本号或时间戳），如果版本匹配则执行更新操作，否则认为发生了冲突。
- 使用场景：乐观锁适用于**读多写少**的场景，可以减少锁的竞争，提高并发性能。例如，数据库中的乐观锁机制可以用于处理并发更新同一行数据的情况。

悲观锁：

- 基本思想：悲观锁假设多个事务之间会频繁发生冲突，因此在**读取数据时会加锁**，防止其他事务对数据进行修改，直到当前事务完成操作后才释放锁。
- 使用场景：悲观锁适用于写多的场景，通过加锁保证数据的一致性。例如，数据库中的行级锁机制可以用于处理并发更新同一行数据的情况。

乐观锁适用于读多写少的场景，通过版本控制来处理冲突；而悲观锁适用于写多的场景，通过加锁来避免冲突。