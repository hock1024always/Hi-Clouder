# 两数之和

## 语法

### 哈希表Map创建初始化

```
hashMap := make(map[key_type]value_type, 10) 
```

上面这是哈希表的含容量写法

```
hashMap := make(map[key_type]value_type) 
```

上面这个是**标准的哈希表写法**

#### 顺带记一下

`make` 和 `new` 都是用于内存分配的内建函数，但它们的使用场景和功能有所不同：

1. **`make`**：
   - 用于初始化并分配内存，只能用于创建 `slice`、`map` 和 `channel` 三种类型。
   - 返回的是初始化后的数据结构，而不是指针。
2. **`new`**：
   - 用于分配内存，但不初始化，返回的是指向该内存的指针。
   - 可以用于任何类型的内存分配。

### 遍历

```
for index, value := range collection {
    // 循环体：使用 index 和 value
}
```

前面是序号，后面是值

### 查找哈希表中元素存在性

通过「键值对 + 存在标志」

`map` 的访问语法 `value, ok := m[key]` 会返回两个值：

- `value`：键对应的值（若键不存在，返回值类型的**零值**，如 `int` 为 `0`，`string` 为 `""`）。
- `ok`：`bool` 类型，`true` 表示键存在，`false` 表示不存在。

### 数组

创建数组

```
var 数组名 [长度]元素类型
arr2 := [3]int{10, 20, 30} // 长度 3，元素 10,20,30
result := []int{key ,order}//不写容量也可以的
```

修改数组传指针

```
func modify(arr *[3]int) {
    arr[0] = 100 // 通过指针修改原数组
}
```

二维数组

## 代码

```go
func twoSum(nums []int, target int) []int {
	//使用哈希表存储差值 差值:序号
	hashMap := make(map[int]int)
	//首先进行一次循环
	for order , value := range nums{
		key,ok := hashMap[value]
		if ok {//存在
			result := []int{key ,order}
			return result
		}
		//不存在 写进去
		hashMap[target-value] = order
	}
	//遍历完不存在的话 返回值为空
	return nil
}
```

哈希表起到的是一个存储标记值的作用，方便我们快速查询

# 字母异位词分组

## 语法

### 字符串

字符串转字节切片

```
s := "eat"
bytes := []byte(s)   // 得到 []byte{'e','a','t'}
```

> Go 的字符串是不可变的，要排序必须先转成 `[]byte`。

对字节切片排序

```go
import "sort"
// 假设 bytes 是 []byte{'e', 'a', 't'}
sort.Slice(bytes, func(i, j int) bool {
    // 如果第 i 个字节 < 第 j 个字节，就认为 i 应该排在 j 前面
    return bytes[i] < bytes[j]
})

//原因是这个断言函数
//func Slice(slice interface{}, less func(i, j int) bool)
//slice：你要排序的切片，比如 []int、[]string、[]byte 都可以。
//less：一个函数，用来回答这个问题：
//“第 i 个元素是不是应该排在第 j 个元素前面？”
//如果你返回 true → 表示 i 应该在 j 前面（升序）
//如果你返回 false → 表示 i 不该在 j 前面（可能交换）
```

> 这是对 `[]byte` 原地排序的标准写法。

字节切片转回字符串

```
sortedStr := string(bytes)  // 比如 "aet"
```

> 排好序的 `[]byte` 可以直接转成 `string` 用作 map 的 key。

map[string] []string 的使用

```
groups := make(map[string][]string)

// 直接 append，无需初始化！
groups[key] = append(groups[key], originalString)
```

> 即使 `key` 不存在，`groups[key]` 是 `nil`，`append(nil, x)` 会自动创建新切片。

### append

追加单个元素

```
// 场景1：追加单个元素
    s1 := []int{1, 2, 3}
    s1 = append(s1, 4) // 必须接收返回值！
```

可追加多元素 

```
// 场景2：追加多个元素
    s2 := []int{1, 2}
    s2 = append(s2, 3, 4, 5)
```

追加切片

```
// 场景3：追加另一个切片（注意末尾的...）
    s3 := []int{1, 2}
    s4 := []int{3, 4}
    s3 = append(s3, s4...) // 用...展开切片
```

### Map大点兵

1. 定义 / 初始化

```
// 方式1：声明+初始化（最常用）
m := make(map[键类型]值类型)          // 空map，比如 m := make(map[string][]string)
m := make(map[string]int, 10)       // 指定初始容量（优化性能，非必需）

// 方式2：字面量初始化（直接赋初始值）
m := map[string]int{"a":1, "b":2}

// 方式3：仅声明（默认nil，不能直接存值，需先make）
var m map[string]int // nil map
```

2. 增 / 改值（键存在则改，不存在则增）

```
m["key"] = value  // 核心写法！刷题中90%的场景用这个
// 例：m["aet"] = []string{"eat", "tea"} （新增键）；m["aet"] = append(m["aet"], "ate")（改值）
```

3. 查值（判断键是否存在）

```
// 方式1：仅取值（键不存在返回值类型零值，比如int返回0，切片返回nil）
v := m["key"]

// 方式2：判断键是否存在（刷题必用！避免零值干扰）
v, ok := m["key"]
if ok {
    // 键存在，v是对应值
} else {
    // 键不存在，v是零值
}
```

4. 删值

```
delete(m, "key")  // 无论键是否存在，都不会报错（刷题清理数据常用）
```

5. 遍历（刷题收集结果常用）

```
// 遍历键值对（顺序不固定，如需有序需先存键排序）
for k, v := range m {
    // k是键，v是值
}

// 仅遍历键
for k := range m {
    // 操作k
}

// 仅遍历值
for _, v := range m {
    // 操作v
}
```

注意

1. **nil map 可查、可删，但不可存值**：`var m map[string]int` 直接 `m["a"]=1` 会 panic，必须先 `m = make(map[string]int)`。
2. **切片作为 map 值**：刷题分组场景（比如字母异位词）常用，记得 `append` 后要赋值回去：`m[key] = append(m[key], val)`。
3. **map 不能直接比较**：判断两个 map 是否相等，需手动遍历键值对比（刷题偶尔会遇到）。



## 代码

这个题目中，哈希表是这样的`map[string][]string`，也就是key是单词顺序排列的“签名”，value是这些单词的数组

```go
func groupAnagrams(strs []string) [][]string {
	//记录同一个签名下面的单词列表  key（签名）：value（单词列表）
	signatures := make(map[string][]string)
	for _,value := range strs{
		//在这里要算出来签名，并且存进去
		value_signature := signature(value)
		_,ok := signatures[value_signature]
		if ok {//存在 追加一个元素
			signatures[value_signature] = append( signatures[value_signature] , value)
		}else{
		    //不存在 创建一个新的键 
		    signatures[value_signature] = []string{value} //注意填入新值
        }
	}
	//输出 遍历map 输出到一个数组里面
	result := [][]string{}
	for _, value := range signatures {
		// result[count] = value//计数器+序号 可能会越界 
        result = append(result,value)
    }

	return result
}

//获取签名
func signature(strs string) string{
	//先换成字符数组 []byte 就是字符数组的格式
	bytes := []byte(strs)
	//用这个Slice排序方式定义规则排序
	sort.Slice(bytes , func(i,j int)bool{//这个方法没有返回值
		return bytes[i] < bytes[j]
	})
	//转换回字符串
	return string(bytes)
}
```

我搞错的地方：

```
for _, value := range signatures {
		// result[count] = value//计数器+序号 可能会越界 
        result = append(result,value)
    }
```

输出越界的问题

```
if ok {//存在 追加一个元素
			signatures[value_signature] = append( signatures[value_signature] , value)
		}else{
		    //不存在 创建一个新的键 
		    signatures[value_signature] = []string{value} //注意填入新值
        }
```

这个下意识不加else，还要注意不存在的时候要填入新值

```
sort.Slice(bytes , func(i,j int)bool{//这个方法没有返回值
		return bytes[i] < bytes[j]
	})
```

这个是个固定用法，第一是这东西没有返回值，第二是不要用原来的字符串加上[i]

# 最长连续序列

这个题目中，哈希表用来**快速校验数字是否存在**以及**避免重复计算**

```
func longestConsecutive(nums []int) int {
    // 快速查找  避免重复计算 value=长度？
    
    //录入哈希表？ key(数字):value(bool)
    hashMap := make(map[int]int)
    for _,value := range nums{
        hashMap[value] = 1 //重复计算重复赋值无所谓 
    }

    //没想到怎么避免重复计算 先硬解
    length := 0
    for _,value := range nums{
        count := 1
        // while hashMap[value+count]{
        //     count++
        // }
        for {
            if hashMap[value+count] == 1 {
                count++
            }
        }

        if count > length{
            length = count
        }
    } 

    return length

}
```

这个算法是错误的，因为没有用到避免重复计算导致超时(也要注意一下go里面没有while)

## 代码

```go
func longestConsecutive(nums []int) int {
    
    //录入哈希表？ key(数字):value(bool)
    hashMap := make(map[int]int)
    for _,value := range nums{
        hashMap[value] = 1 //重复计算重复赋值无所谓 
    }

    //怎么避免重复计算呢？ 看一下比该数小1的的位置是不是1 是的话就说明不是起点 就不算了
    length := 0
    for _,value := range nums{
        if hashMap[value-1] == 1{//并非起点
            continue
        }
        count := 1
        for hashMap[value+count] == 1 {
            count++
        }

        if count > length{
            length = count
        }
    } 

    return length

}
```

# 总结

### 一、什么时候该想到用哈希表？（核心场景）

从这三道题和 LeetCode 高频场景来看，只要遇到以下 4 类问题，优先考虑哈希表：

#### 1. 快速存在性 / 关联性查询（最核心）

- 场景特征：需要频繁判断 “某个元素是否存在”“某个元素对应的另一个值是什么”，替代遍历（O (n)→O (1)）。
- 例子：
  - 两数之和：查 “target-value” 是否存在，快速找对应下标；
  - 最长连续序列：查 “num-1/num+count” 是否存在，判断起点 / 连续数；
  - 延伸：判断数组是否有重复元素、找两个数组的交集等。

#### 2. 分组 / 归类统计

- 场景特征：需要按 “某个特征（签名）” 把元素分成不同组，或统计元素出现次数。
- 例子：
  - 字母异位词分组：按 “排序后的签名” 分组；
  - 延伸：统计字符串中字符出现次数、按频率给元素排序等。

#### 3. 避免重复计算 / 遍历

- 场景特征：需要标记 “已处理过的元素”，防止重复操作导致时间复杂度超标。
- 例子：
  - 最长连续序列：标记 “非起点元素” 直接跳过，避免 O (n²) 遍历；
  - 延伸：路径去重、图的遍历中标记已访问节点等。

#### 4. 映射关系存储

- 场景特征：需要建立 “键→值” 的一一 / 一对多映射，快速通过键找值。
- 例子：
  - 两数之和：存储 “差值→下标”；
  - 延伸：罗马数字转整数（字符→数值映射）、同构字符串（字符→字符映射）等。

### 二、哈希表常规用法拓展 + 练习题目（附链接 + 核心作用）

按 “基础→进阶” 排序，每道题标注哈希表的核心作用，方便你针对性练习：

|                           题目链接                           |         题目名称         | 难度 |                        哈希表核心作用                        |
| :----------------------------------------------------------: | :----------------------: | :--: | :----------------------------------------------------------: |
| [217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/) |       存在重复元素       | 简单 |     快速判断元素是否已出现，遍历一次即可（替代双重循环）     |
| [219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/) |     存在重复元素 II      | 简单 |       存储 “元素→最新下标”，判断重复元素的下标差是否≤k       |
| [387. 字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string/) | 字符串中的第一个唯一字符 | 简单 |  统计 “字符→出现次数”，再遍历字符串找第一个次数为 1 的字符   |
| [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)（已做） |      字母异位词分组      | 中等 |        按 “排序签名→字符串列表” 分组，实现异位词归类         |
| [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) |     前 K 个高频元素      | 中等 | 第一步：统计 “元素→出现频率”；第二步：按频率分组（频率→元素列表），快速找前 k 个 |
| [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)（已做） |       最长连续序列       | 中等 |      快速判断数字是否存在 + 标记非起点元素避免重复计算       |
| [1. 两数之和](https://leetcode.cn/problems/two-sum/)（已做） |         两数之和         | 简单 |            存储 “差值→下标”，快速查询互补数的位置            |
| [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/) |        同构字符串        | 简单 | 建立双向映射（s 字符→t 字符、t 字符→s 字符），判断映射是否唯一 |
| [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) |     有效的字母异位词     | 简单 |    统计 “字符→出现次数”，对比两个字符串的字符计数是否一致    |
|  [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)   |       四数相加 II        | 中等 | 拆分两组，统计 “前两组和→出现次数”，再查后两组的互补和是否存在，累加次数 |

### 三、总结

1. **哈希表核心使用场景**：快速查询存在性、分组统计、避免重复计算、存储键值映射，核心是把 O (n) 的查询 / 遍历降到 O (1)。
2. **练习优先级**：先做简单题（217/219/387/205/242）巩固基础用法，再做中等题（347/454）拓展哈希表的 “统计 + 二次查询” 用法。
3. **关键技巧**：刷题时只要遇到 “需要反复查元素、统计次数、分组归类”，第一时间想到哈希表，优先用 map 实现，注意 nil map 的初始化、ok 判断避免零值干扰。