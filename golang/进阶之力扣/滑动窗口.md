# 总结

### 一、滑动窗口核心使用方法

滑动窗口本质是**用两个指针（左 / 右指针）维护一个「动态区间」**，通过移动指针来调整区间的大小和位置，从而在 O (n) 或 O (nk) 的时间复杂度内解决问题，核心步骤可总结为：

1. **初始化**：定义左指针 `left`（通常初始为 0）、右指针 `right`（遍历用），以及需要的辅助变量（如哈希表、计数器、结果变量）；
2. **扩展右边界**：右指针逐个遍历元素，将元素纳入窗口，更新辅助变量；
3. **收缩左边界**：当窗口内的元素不满足「题目条件」时（如出现重复、窗口和超过阈值），移动左指针缩小窗口，直到条件重新满足；
4. **更新结果**：在遍历过程中，持续计算当前窗口的有效信息（如长度、和、数量），更新最终结果。

根据窗口收缩的规则，滑动窗口可分为两类：

- **固定窗口**：窗口大小固定（如找长度为 k 的子数组最大值），只需同步移动左右指针；
- **可变窗口**：窗口大小动态调整（如本次的无重复最长子串），是更常见的考察形式。

### 二、滑动窗口适用场景

滑动窗口主要解决**一维序列（字符串 / 数组）的子串 / 子数组问题**，尤其适合以下场景：

1. 找「满足某条件的最长 / 最短子串 / 子数组」（如无重复最长子串、最小覆盖子串）；
2. 找「子串 / 子数组的和 / 积 / 数量满足条件」的问题（如和为 k 的子数组、乘积小于 k 的子数组）；
3. 找「包含所有目标字符的子串」（如最小覆盖子串、串联所有单词的子串）；
4. 找「无重复 / 最多 k 个重复字符的子串」（如至多包含两个不同字符的最长子串）。

核心特征：问题围绕「连续的子序列」展开，且可通过调整窗口边界快速排除无效区间，避免暴力枚举的 O (n²) 复杂度。

### 三、力扣经典练习题（按难度排序）

#### 入门级（理解基础用法）

1. [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)（本次练习的题，可变窗口核心）
2. [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)（找和≥target 的最短子数组，可变窗口）
3. [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)（固定窗口，基础练手）

#### 进阶级（掌握窗口收缩逻辑）

1. [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)（困难，但滑动窗口经典必做，找包含所有目标字符的最小子串）
2. [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)（可变窗口，条件为「最多 k 个不同字符」）
3. [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)（固定窗口，找异位词的起始索引）

#### 拓展级（综合应用）

1. [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)（固定窗口，判断一个字符串的排列是否是另一个的子串）
2. [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)（实际是「至多包含 2 个不同字符的最长子串」，场景化包装）
3. [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)（可变窗口，统计满足条件的子数组数量）

### 总结

1. 滑动窗口核心是「双指针维护动态区间」，通过扩展右边界、收缩左边界，在 O (n) 时间内解决连续子序列问题；
2. 适用场景聚焦「一维连续子串 / 子数组」，尤其适合找最长 / 最短、满足和 / 字符条件的子序列；

# 无重复字符的最长子串（变长窗口问题）

这个题目的思路是：

1. 快指针跟着循环走，慢指针牟定最远没有重复的位置（这也就意味着只需要在出现重复的在窗口中时，才更新慢的位置）
2. 标记位置使用哈希表

```
func lengthOfLongestSubstring(s string) int {
	//需要快慢指针组成滑动窗口  哈希表记录一下元素位置  还有一个最大长度的记录
	result := 0
	slow := 0
	hashMap := make(map[byte]int)//记录字符以及最后出现的位置
	//字符串拆分成字符数组
	bytes := []byte(s)
	//快指针循环 慢指针跟进 看新包含的字母有没有在窗口中出现
	for index,value := range bytes{
		if pos,ok := hashMap[value];ok && pos >= slow{//说明在窗口里面
			
			//slow = index+1
			slow = hashMap[value] + 1
		}
		
		if result < index - slow + 1{
			result = index - slow + 1
		}
		
		hashMap[value] = index
	}

	return result
}
```

我出错的两个点：

1. 就是slow要更新到重复字母上次出现位置往后一个
2. 更新长度需要每次循环都更新，而不是遇到重复再更新，因为可能会有你走到最后都没有重复的

# 异构词（固定窗口问题）
