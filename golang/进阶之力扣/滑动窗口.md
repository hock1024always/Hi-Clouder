# 总结

### 一、滑动窗口核心使用方法

滑动窗口本质是**用两个指针（左 / 右指针）维护一个「动态区间」**，通过移动指针来调整区间的大小和位置，从而在 O (n) 或 O (nk) 的时间复杂度内解决问题，核心步骤可总结为：

1. **初始化**：定义左指针 `left`（通常初始为 0）、右指针 `right`（遍历用），以及需要的辅助变量（如哈希表、计数器、结果变量）；
2. **扩展右边界**：右指针逐个遍历元素，将元素纳入窗口，更新辅助变量；
3. **收缩左边界**：当窗口内的元素不满足「题目条件」时（如出现重复、窗口和超过阈值），移动左指针缩小窗口，直到条件重新满足；
4. **更新结果**：在遍历过程中，持续计算当前窗口的有效信息（如长度、和、数量），更新最终结果。

根据窗口收缩的规则，滑动窗口可分为两类：

- **固定窗口**：窗口大小固定（如找长度为 k 的子数组最大值），只需同步移动左右指针；
- **可变窗口**：窗口大小动态调整（如本次的无重复最长子串），是更常见的考察形式。

### 二、滑动窗口适用场景

滑动窗口主要解决**一维序列（字符串 / 数组）的子串 / 子数组问题**，尤其适合以下场景：

1. 找「满足某条件的最长 / 最短子串 / 子数组」（如无重复最长子串、最小覆盖子串）；
2. 找「子串 / 子数组的和 / 积 / 数量满足条件」的问题（如和为 k 的子数组、乘积小于 k 的子数组）；
3. 找「包含所有目标字符的子串」（如最小覆盖子串、串联所有单词的子串）；
4. 找「无重复 / 最多 k 个重复字符的子串」（如至多包含两个不同字符的最长子串）。

核心特征：问题围绕「连续的子序列」展开，且可通过调整窗口边界快速排除无效区间，避免暴力枚举的 O (n²) 复杂度。

### 三、力扣经典练习题（按难度排序）

#### 入门级（理解基础用法）

1. [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)（本次练习的题，可变窗口核心）
2. [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)（找和≥target 的最短子数组，可变窗口）
3. [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)（固定窗口，基础练手）

#### 进阶级（掌握窗口收缩逻辑）

1. [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)（困难，但滑动窗口经典必做，找包含所有目标字符的最小子串）
2. [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)（可变窗口，条件为「最多 k 个不同字符」）
3. [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)（固定窗口，找异位词的起始索引）

#### 拓展级（综合应用）

1. [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)（固定窗口，判断一个字符串的排列是否是另一个的子串）
2. [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)（实际是「至多包含 2 个不同字符的最长子串」，场景化包装）
3. [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)（可变窗口，统计满足条件的子数组数量）

### 总结

1. 滑动窗口核心是「双指针维护动态区间」，通过扩展右边界、收缩左边界，在 O (n) 时间内解决连续子序列问题；
2. 适用场景聚焦「一维连续子串 / 子数组」，尤其适合找最长 / 最短、满足和 / 字符条件的子序列；

# 无重复字符的最长子串（变长窗口问题）

这个题目的思路是：

1. 快指针跟着循环走，慢指针牟定最远没有重复的位置（这也就意味着只需要在出现重复的在窗口中时，才更新慢的位置）
2. 标记位置使用哈希表

```
func lengthOfLongestSubstring(s string) int {
	//需要快慢指针组成滑动窗口  哈希表记录一下元素位置  还有一个最大长度的记录
	result := 0
	slow := 0
	hashMap := make(map[byte]int)//记录字符以及最后出现的位置
	//字符串拆分成字符数组
	bytes := []byte(s)
	//快指针循环 慢指针跟进 看新包含的字母有没有在窗口中出现
	for index,value := range bytes{
		if pos,ok := hashMap[value];ok && pos >= slow{//说明在窗口里面
			
			//slow = index+1
			slow = hashMap[value] + 1
		}
		
		if result < index - slow + 1{
			result = index - slow + 1
		}
		
		hashMap[value] = index
	}

	return result
}
```

我出错的两个点：

1. 就是slow要更新到重复字母上次出现位置往后一个
2. 更新长度需要每次循环都更新，而不是遇到重复再更新，因为可能会有你走到最后都没有重复的

# 异构词（固定窗口问题）

## 字符串方法

### 一、核心类型对比（算法题高频）

| 语法 / 类型 |         类型本质         |  字面量写法  |                  适用场景                   |            力扣高频用法            |
| :---------: | :----------------------: | :----------: | :-----------------------------------------: | :--------------------------------: |
|   `byte`    | uint8 别名（单字节字符） | 无独立字面量 |    处理 ASCII 字符（a-z、0-9、基础符号）    | 统计字符计数、字符串转字节数组操作 |
|   `rune`    | int32 别名（多字节字符） | 无独立字面量 |       处理中文、emoji 等 Unicode 字符       | 含中文的字符串遍历、多字节字符统计 |
|    `'a'`    | 字符字面量（rune 类型）  |    单引号    | 单个字符的常量 / 运算（ASCII/Unicode 均可） | 字符转索引（如 `c-'a'`）、字符对比 |
|    `"a"`    |  字符串（string 类型）   |    双引号    |         字符串常量、完整字符串操作          |   输入输出、子串截取、字符串遍历   |
|  `[]byte`   |  字节切片（byte 数组）   |      无      |      字符串的可变操作（string 不可变）      |    字符串修改、滑动窗口字符统计    |

### 二、核心语法规则（算法题必记）

#### 1. 字符 / 字符串基础运算

|        操作场景        |          正确写法           |    错误写法     |                   说明                   |
| :--------------------: | :-------------------------: | :-------------: | :--------------------------------------: |
| ASCII 字符转 0-25 索引 | `c - 'a'`（c 是 byte/rune） |    `c - "a"`    |     双引号是字符串，无法和字符做减法     |
|        字符对比        |        `s[i] == 'a'`        |  `s[i] == "a"`  | 字符串 [i] 返回 byte，只能和字符字面量比 |
|       字符串长度       |      `len("abc")` → 3       | `len("中")` → 3 |  len (string) 算**字节数**，不是字符数   |
|  实际字符数（含中文）  |   `len([]rune("中"))` → 1   |        -        |     转 rune 切片后 len 是真实字符数      |

#### 2. 类型转换（算法题高频）

|       转换需求        |         正确写法          |               注意事项                |
| :-------------------: | :-----------------------: | :-----------------------------------: |
|   字符串转字节数组    |      `[]byte("abc")`      | 仅适用于 ASCII 字符，中文会拆成多字节 |
|   字节数组转字符串    | `string([]byte{'a','b'})` |         转回后是不可变字符串          |
|  字符串转 rune 切片   |     `[]rune("中国")`      |    每个元素是一个完整 Unicode 字符    |
| rune 转 byte（ASCII） |        `byte('a')`        |   仅 ASCII 字符可用，中文会丢失数据   |

#### 3. 遍历规则（算法题必懂）

|      遍历方式      |                写法示例                |               适用场景               |
| :----------------: | :------------------------------------: | :----------------------------------: |
| 按字节遍历（默认） | `for i := 0; i < len(s); i++ { s[i] }` |   仅 ASCII 字符串（力扣多数场景）    |
| 按字符遍历（推荐） |      `for i, c := range s { c }`       | 兼容所有字符（ASCII / 中文 / Emoji） |

### 三、力扣算法题高频用法示例

#### 1. 字符计数（滑动窗口必备）

```
// 统计 ASCII 字符计数（byte 数组，效率最高）
count := [26]int{}
count['c'-'a']++ // 正确：'c'是字符字面量，转成索引2
// 错误：count["c"-"a"] → 字符串无法减法

// 统计含中文的字符计数（用 map[rune]int）
countRune := make(map[rune]int)
for _, c := range "中国a" {
    countRune[c]++ // c 是 rune 类型，兼容中文
}
```

#### 2. 字符串不可变 → 转 [] byte 修改

```
s := "abc"
// 错误：s[0] = 'A' → string 不可变
bs := []byte(s)
bs[0] = 'A' // 正确：字节切片可变
newS := string(bs) // 转回字符串 → "Abc"
```

#### 3. 遍历含中文的字符串

```
s := "ab中cd"
// 按字节遍历（错误，中文拆成3字节）
for i := 0; i < len(s); i++ {
    fmt.Println(s[i]) // 输出：97 98 228 184 173 99 100
}
// 按字符遍历（正确）
for i, c := range s {
    fmt.Println(i, c) // 输出：0 97, 1 98, 2 20013, 5 99, 6 100
}
```

### 总结

1. **核心区分**：单引号是字符（'a'）、双引号是字符串（"a"），算法题中字符运算必须用单引号；
2. **高频转换**：string 转 [] byte 做修改，ASCII 字符用 `c-'a'` 转索引，含中文用 rune；
3. **遍历规则**：range 遍历字符串是按字符（rune），for+len 是按字节（byte），力扣优先用 range。

## 代码

```go
func findAnagrams(s string, p string) []int {
	//初始化和边界检查
	result := []int{}
	if len(p)>len(s){
		return result
	}

	//异构词的本质上是出现的每个字母出现的次数，如果这个一致的话就是一个异构词
	count_p_chs := [26]int{}//使用一个数组记录词出现字母的个数(如何统计有特殊的写法)
	count_s_chs := [26]int{}

	// 统计p的字符计数，同时初始化s前len(p)个字符的计数（第一个窗口）
	pLen := len(p)
	for i := 0; i < pLen ;i++{
		count_p_chs[p[i]-'a']++
		count_s_chs[s[i]-'a']++
	}

	//检查窗口（第一个）
	if count_s_chs == count_p_chs {
		result = append(result,0)
	}

	//滑动这个固定窗口
	for right := pLen;right<len(s);right++{
		//s撤掉左侧的
		count_s_chs[s[right-pLen]-'a']--
		//添上右边的
		count_s_chs[s[right]-'a']++
		//对比窗口
		if count_s_chs == count_p_chs {
			result = append(result,right-pLen+1)
		}
	}
	return result
}
```

