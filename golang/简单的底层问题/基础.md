## 错误类型

能用 `error` 就不用 `panic`；要用 `panic`，务必配 `recover`；自定义错误 + 错误链 = 专业级错误处理。

Go语言错误的三种处理方法

| 方法                                          | 用途（含例子）                                               | 特点                                                         | 使用建议                                                     |
| --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. `error` 接口 + 显式返回**                | 处理**可预期、可恢复的错误** 👉 例如：打开文件失败、除零错误、网络超时 | - 所有错误都实现 `error` 接口 - 函数通过最后一个返回值返回 `error` - 必须显式检查 `if err != nil` | ✅ Go 的主流错误处理方式 ✅ 鼓励在业务逻辑中广泛使用           |
| **2. 自定义错误 + `errors.Is` / `errors.As`** | 提供**带上下文或可区分类型的错误** 👉 例如：HTTP 404 错误携带状态码，数据库连接失败包含地址信息 | - 可携带额外字段（如错误码） - Go 1.13+ 支持 `%w` 包装错误 - `errors.Is` 判断是否包含某错误 - `errors.As` 转换为具体错误类型 | ✅ 适合构建健壮、可测试的系统 ✅ 推荐用于库开发或复杂业务错误  |
| **3. `panic` + `recover`**                    | 应对**不可恢复的严重异常** 👉 例如：程序启动时配置文件缺失、关键指针为 nil、断言失败 | - `panic` 立即终止当前 goroutine 的正常流程 - `recover` **只能在 defer 中调用**才能生效 - 不会跨 goroutine 恢复 | ⚠️ 慎用！仅用于真正致命的场景 ❌ 不应替代 `error` 处理常规错误 |

------

1.  使用 `error` 显式返回错误

   ```go
   func divide(a, b int) (int, error) {
       if b == 0 {
           return 0, errors.New("division by zero")
       }
       return a / b, nil
   }
   
   // 调用
   _, err := divide(10, 0)
   if err != nil {
       fmt.Println(err) // 输出: division by zero
   }
   ```

2. 自定义错误 + 错误包装（Go 1.13+）

   ```go
   var ErrNotFound = errors.New("not found")
   
   func find(id int) error {
       return fmt.Errorf("DB: %w", ErrNotFound)
   }
   
   err := find(1)
   if errors.Is(err, ErrNotFound) {
       fmt.Println("Item not found") // 输出: Item not found
   }
   ```

3. ```go
   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("Recovered:", r) // 输出: Recovered: config file missing!
           }
       }()
       panic("config file missing!")
   }
   ```
   
   - 因为panic报的错会终止程序，在这个阶段首先会回溯调用栈（也就是找并且执行defer），所以必须写到defer里面才有用
   - `recover` 是一个内置函数，用于**捕获并中止 panic**，从而防止程序崩溃，调用成功之后程序会从panic恢复正常状态

## 协程

1. 协程是用户态轻量级线程，它是线程调度的基本单位。
2. 一个Goroutine会以一个很小的栈启动2KB，当遇到**栈空间不足时，栈会自动伸缩**， 因此可以轻易实现成千上万个goroutine同时启动。而线程在Linux上是8MB而且不会自动伸缩，所以协程就很有优势



## 协程和线程和进程的区别

- 进程:进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
- 线程:线程是进程的一个实体,线程是内核态,而且是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
- 协程:协程是一种**用户态的轻量级线程**，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

| 特性维度          | 进程                                                | 线程                                                   | 协程（goroutine）                      |
| :---------------- | :-------------------------------------------------- | :----------------------------------------------------- | :------------------------------------- |
| **基本定义**      | 资源分配和拥有的基本单位                            | CPU调度和执行的基本单位                                | **用户态**的轻量级线程，由用户控制调度 |
| **与进程的关系**  | -                                                   | 进程的一个实体                                         | 可视为在线程中运行的微线程             |
| **资源开销**      | 大（独立内存空间、文件句柄等）                      | 小（共享进程资源）                                     | 极小（通常只需保存寄存器上下文和栈）   |
| **切换开销**      | 大（需要切换内存空间、内核栈等，**CPU上下文切换**） | 中（需通过操作系统内核调度，**CPU上下文切换**）        | 小（**在用户态完成**，无需内核介入）   |
| **独立性**        | 高，相互隔离，互不影响                              | 低，同进程内线程共享内存，一个崩溃可能导致整个进程崩溃 | 极高，在同一线程内运行，协作式切换     |
| **通信机制**      | 进程间通信（IPC），如管道、消息队列、共享内存等     | 共享内存（读写同一进程的全局变量）                     | 共享内存（通过通道、全局变量等通信）   |
| **并发性**        | 进程间并发                                          | 线程间并发                                             | 协程间并发（协作式）                   |
| **稳定性/安全性** | 高（内存隔离）                                      | 中（共享内存需同步，易导致数据竞争、死锁）             | 依赖用户正确设计和调度，需避免阻塞操作 |
| **核心归属**      | 操作系统内核                                        | 操作系统内核                                           | 用户程序（语言运行时库或框架）         |

1.  **资源与调度**：
    *   **进程** 是资源的“容器”，操作系统以进程为单位分配内存、文件等资源。
    *   **线程** 是执行的“单元”，操作系统以线程为单位在CPU上调度执行。一个进程至少有一个线程。
    *   **协程** 的调度完全在**用户态**由程序自己控制，不经过操作系统内核，这是其开销极小的根本原因。

2.  **开销对比**：
    *   **进程切换**：开销最大，需要切换页表（虚拟内存空间）、内核栈、硬件上下文等。
    *   **线程切换**：开销中等，发生在同一进程内，因此虚拟内存空间不变，但仍需切换内核栈和硬件上下文。
    *   **协程切换**：开销极小，本质是**在用户态**保存和恢复寄存器（如栈指针、指令指针等）和少量变量，通常只需几十纳秒。

3.  **比喻理解**：
    *   **进程** 像一个独立的“工厂”，拥有自己的土地（内存空间）、资源（文件、设备）。
    *   **线程** 像工厂里的“工人”，共享工厂的资源，协同完成工作。
    *   **协程** 像工人手中的“微任务”，工人可以主动暂停一个微任务，转去做另一个，而不需要离开工位（线程）或请示经理（操作系统）。

## make 和 new 的区别

`make` 和 `new` 都是用于内存分配的内建函数

1. **`make`**：
   - 用于初始化并分配内存，只能用于创建 `slice`、`map` 和 `channel` 三种类型。
   - **返回的是初始化后的数据结构**，而不是指针。
2. **`new`**：
   - 用于分配内存，但不初始化，**返回的是指向该内存的指针**。
   - 可以用于任何类型的内存分配。

```go
// 使用 make 创建 slice
s := make([]int, 5) // 创建一个长度为 5 的 slice
fmt.Println(s)      // 输出: [0 0 0 0 0]// 使用 new 创建 int 指针
p := new(int)       // 分配内存给 int 类型
fmt.Println(*p)     // 输出: 0 (初始值)
```

## 数组和切片的区别

数组：

1. 数组固定长度，数组长度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组
2. 类型数组需要指定大小，不指定也会根据初始化，自动推算出大小， 大小不可改变
3. 数组是通过值传递的

切片：

1. 切片可以改变长度。切片是轻量级的数据结构，三个属性——指针，长度，容量 
2. 不需要指定大小切片是地址传递(引用传递)
3. 可以通过数组来初始化，也可以通过内置函数 make()来初始化，初始化的时候`len=cap`，然后进行扩容

```go
//切片数据结构
type slice struct {
        array unsafe.Pointer // 元素指针
        len   int // 长度 
        cap   int // 容量
}
```

![img](./图片/image.png)

## 使用for range 的时候，它的地址会发生变化吗

```go
for index, value := range collection {
    // ...
}
```

在Go1.22之前，对于 `for range` 循环中的迭代变量，其内存地址是不会发生变化的

1.  `value` 是一个**副本**。在每次迭代中，`collection` 中的当前元素值会被**复制**到 `value` 这个变量中。
2. Go 编译器通常会为 `value` 分配一块固定的内存地址，然后在每次迭代时，将当前元素的值**覆盖**到这块内存中

Go1.22之后的地址是临时的，是变化的，不一样的，不再是共享内存了

1. **迭代变量的地址会发生变化**
2. 因为 `for range` 每次迭代时都会重新生成迭代变量（如 `value`），这些变量在内存中是不同的地址

## 如何高效地拼接字符串

1. "+": 使用`+`操作符进行拼接时，会对字符串进行**遍历**，计算并开辟一个**新的空间**来存储原来的两个字符串。
2. `fmt.Sprintf`: 由于采用了接口参数，必须要**用反射获取值**，因此有性能损耗。
3. `strings.Builder`：用`WriteString()`进行拼接，内部实现是**指针+切片**，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝。
4. `bytes.Buffer`:`bytes.Buffer`是一个一个缓冲`byte`类型的**缓冲器**，这个缓冲器里存放着都是`byte`，`bytes.buffer`底层也是一个`[]byte`切片。
5. `strings.join`: `strings.join`也是基于`strings.builder`来实现的,并且可以自定义分隔符，在join方法内调用了`b.Grow(n)`方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。

`strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf`

5种拼接方法的实例代码

```go
func main(){
        a := []string{"a", "b", "c"}
        //方式1：+
        ret := a[0] + a[1] + a[2]
        //方式2：fmt.Sprintf
        ret := fmt.Sprintf("%s%s%s", a[0],a[1],a[2])
        //方式3：strings.Builder
        var sb strings.Builder
        sb.WriteString(a[0])
        sb.WriteString(a[1])
        sb.WriteString(a[2])
        ret := sb.String()
        //方式4：bytes.Buffer
        buf := new(bytes.Buffer)
        buf.Write(a[0])
        buf.Write(a[1])
        buf.Write(a[2])
        ret := buf.String()
        //方式5：strings.Join
        ret := strings.Join(a,"")
}
```

## defer 的执行顺序是怎样的

defer执行顺序和调用顺序相反，类似于栈后进先出(LIFO)

常用场景:

- defer语句经常被用于**处理成对的操作**，如打开、关闭、连接、断开连接、 加锁、释放锁。
- 通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，**资源被释放**。
- 释放资源的defer应该直接跟在请求资源的语句后。

## rune 类型

字符有以下两种：

- uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
- rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。

##  tag 有什么用

tag可以为结构体成员提供属性。常见的：

1. json序列化或反序列化时字段的名称
2. db: sqlx模块中对应的数据库字段名
3. form: gin框架中对应的前端的数据字段名
4. binding: 搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端

## %v %+v %#v 的区别

- %v 只输出所有的值；
- %+v 先输出字段名字，再输出该字段的值；
- %#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；

## 空 struct{} 占用空间么

不占用

## 空 struct{} 有什么用

- 用map模拟一个set，那么就要把值置为struct{}，struct{}本身不占任何空间，可以避免任何多余的内存分配

- 有时候给通道发送一个空结构体,channel<-struct{}{}，可以节省空间

- 表示仅有方法的结构体

## `init()` 函数是什么时候执行的

1. 同一个go文件中的执行顺序：import –> const –> var –>`init()`–>`main()`
2. 同一个包不同的go文件中`init`函数执行顺序：按编译器处理文件的顺序
3. 不同包的`init`函数的执行顺序：按导入的依赖关系，**被导入的包先初始化**

##  2个interface可以比较吗

Go 语言中，interface 的内部实现包含了 2 个字段，类型 `T` 和 值 `V`，interface 可以使用 `==` 或 `!=` 比较。2 个 interface 相等有以下 2 种情况

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
2. 类型 T 相同，且对应的值 V 相等。

## 2个nil可能不相等吗

可能不等。interface在运行时绑定值，只有值为nil接口值才为nil，但是与指针的nil不相等(必须还要类型相同)

```go
var p *int = nil
var i interface{} = nil
if(p == i){
        fmt.Println("Equal")
}
```

## 函数传参是值类型还是引用类型

在 Go 语言中只存在值传递，要么是值的副本，要么是**指针的副本(引用类型)**。无论是值类型的变量还是引用类型的变量亦或是指针类型的变量作为参数传递都会发生值拷贝，开辟新的内存空间。

值传递、引用传递和值类型、引用类型是两个不同的概念，不要混淆了。引用类型作为变量传递可以影响到函数外部是因为发生值拷贝后新旧变量指向了相同的内存地址。

## 如何知道一个对象是分配在栈上还是堆上

1. Go局部变量会进行逃逸分析。如果变量离开作用域后没有被引用，则**优先分配到栈上，否则分配到堆上**
2. 测试命令：`go build -gcflags '-m -m -l' xxx.go`
3. 关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针

## 多返回值是如何实现的

1. 通过在函数**调用栈帧上预留空间**并进行**值复制**
2. 在函数调用发生时，Go 编译器会计算出函数所有返回值的总大小。在为该函数创建**栈帧**时，就会在调用方（caller）的栈帧上，为这些返回值预留出**连续的内存空间**
3. 函数执行到 `return` 语句时，它会将其要返回的各个值**复制**到这些预留好的栈空间中
4. 函数执行完毕后，控制权返回给调用方，调用方可以直接从它自己的栈帧上（即之前为返回值预留的空间）获取这些返回的值

## Go语言中"_"的作用

1. 忽略多返回值

2. 当你导入一个包时，通常会使用它的某个功能。但有时你可能只想执行包的 `init()` 函数（例如，注册驱动、初始化全局变量等），而不需要直接使用包中的任何导出成员。这时，你就可以使用 `_` 来进行**匿名导入**

   ```go
   import (
           "fmt"
           _ "net/http/pprof" // 导入 pprof 包，只为了执行其 init 函数注册 profiling 接口
   )
   
   func main() {
           fmt.Println("Application started. Profiling tools are likely registered.")
           // 实际应用中，你可能还会启动一个 HTTP 服务器来暴露 pprof 接口
           // go func() {
           //         log.Println(http.ListenAndServe("localhost:6060", nil))
           // }()
   }
   ```

## 普通指针和`unsafe.Pointer`有什么区别

1. 普通指针比如`*int`、`*string`，它们有明确的类型信息，编译器会进行类型检查和垃圾回收跟踪，不同类型的指针之间不能直接转换
2. `unsafe.Pointer`是Go的通用指针类型，可以理解为C语言中的`void*`，它绕过了Go的类型系统，`unsafe.Pointer`可以**与任意类型的指针相互转换**，也可以与uintptr进行转换来**做指针运算**，通指针受GC管理和类型约束，unsafe.Pointer不受类型约束但**仍受GC跟踪**

## unsafe.Pointer与uintptr有什么区别和联系

1. 联系：unsafe.Pointer和uintptr可以相互转换，这是Go提供的唯一合法的指针运算方式，典型用法是先将unsafe.Pointer转为uintptr做算术运算，再转回unsafe.Pointer使用
2. 区别：unsafe.Pointer有GC保护，uintptr没有，这是它们最本质的区别（uintptr只是一个普通整数，GC完全不知道它指向什么，如果没有其他引用，对应内存可能随时被回收）