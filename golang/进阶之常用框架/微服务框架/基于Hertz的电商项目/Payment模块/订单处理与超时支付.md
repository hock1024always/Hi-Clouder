# 实施方案图

```mermaid
graph TD
    subgraph A [订单创建与库存锁定]
        A1[客户端创建订单请求] --> A2[订单服务];
        A2 --> A3{库存服务.预占库存};
        A3 --> A4[锁定成功];
        A4 --> A5[GORM事务写入];
        A5 --> A6[订单头表];
        A5 --> A7[订单明细表];
        A6 --> A8[返回待支付订单];
    end

    subgraph B [支付流程]
        B1[用户选择支付方式] --> B2[支付策略工厂];
        B2 --> B3[微信支付策略];
        B2 --> B4[支付宝支付策略];
        B2 --> B5[银联支付策略];
        B3/B4/B5 --> B6[生成支付参数];
        B6 --> B7[写入支付请求表];
        B7 --> B8[跳转支付网关];
    end

    subgraph C [支付回调处理]
        C1[支付平台异步回调] --> C2[回调验证];
        C2 --> C3[更新支付回调表];
        C3 --> C4{GORM事务更新};
        C4 --> C5[更新订单状态];
        C4 --> C6[更新支付状态];
        C4 --> C7[扣减真实库存];
    end

    subgraph D [支付超时处理 - 三种方案]
        subgraph D1 [方案一：扫表轮询]
            D11[定时任务] --> D12[扫描超时订单];
            D12 --> D13[批量处理];
            D13 --> D14[释放预占库存];
            D14 --> D15[订单状态改为超时关闭];
        end
        
        subgraph D2 [方案二：延时队列]
            D21[创建订单] --> D22[发送延时消息];
            D22 --> D23[MQ延时队列];
            D23 --> D24[消息到期消费];
            D24 --> D25[检查订单状态];
            D25 --> D26[未支付则关闭];
        end
        
        subgraph D3 [方案三：Redis过期]
            D31[创建订单] --> D32[Redis.setex订单号];
            D32 --> D33[Redis键过期];
            D33 --> D34[过期事件通知];
            D34 --> D35[处理超时订单];
        end
    end

    A8 --> B1;
    B8 --> C1;
    A3 -.-> D14;
```

# 具体方案

## 1. 订单创建与库存锁定（GORM事务）

```go
// 订单创建服务
type OrderService struct {
    db *gorm.DB
}

func (s *OrderService) CreateOrder(req *CreateOrderRequest) (*Order, error) {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 创建订单头
        orderHeader := &OrderHeader{
            OrderNo:    generateOrderNo(),
            UserID:     req.UserID,
            Status:     OrderStatusPending,
            TotalAmount: req.TotalAmount,
        }
        if err := tx.Create(orderHeader).Error; err != nil {
            return err
        }

        // 2. 创建订单明细
        for _, item := range req.Items {
            orderItem := &OrderItem{
                OrderID:   orderHeader.ID,
                ProductID: item.ProductID,
                Quantity:  item.Quantity,
                Price:     item.Price,
            }
            if err := tx.Create(orderItem).Error; err != nil {
                return err
            }
        }

        // 3. 预占库存
        if err := s.inventoryService.LockInventory(tx, req.Items); err != nil {
            return err
        }

        return nil
    })
}
```

```mermaid
graph TD
    A[开始创建订单] --> B[开启GORM事务];
    B --> C[创建订单头记录];
    C --> D{创建成功?};
    D -->|是| E[循环创建订单明细];
    D -->|否| F[回滚事务];
    E --> G{所有明细成功?};
    G -->|是| H[预占库存];
    G -->|否| F;
    H --> I{库存锁定成功?};
    I -->|是| J[提交事务];
    I -->|否| F;
    J --> K[返回订单创建成功];
    F --> L[返回错误信息];
```

**流程图解释：**
- 整个流程在数据库事务中执行，保证原子性
- 任何步骤失败都会触发事务回滚
- 只有所有步骤成功才提交事务
- 库存预占与订单创建在同一个事务中

## 2. 支付策略模式实现

```go
// 支付策略接口
type PaymentStrategy interface {
    Pay(request *PayRequest) (*PayResponse, error)
    Refund(request *RefundRequest) (*RefundResponse, error)
}

// 策略工厂
type PaymentFactory struct{}

func (f *PaymentFactory) GetStrategy(payType string) PaymentStrategy {
    switch payType {
    case "wechat":
        return &WechatPayment{}
    case "alipay":
        return &AlipayPayment{}
    case "unionpay":
        return &UnionPayment{}
    default:
        return nil
    }
}

// 支付服务
type PaymentService struct {
    db       *gorm.DB
    factory  *PaymentFactory
}

func (s *PaymentService) CreatePayment(orderID uint, payType string) error {
    // 写入支付请求表
    paymentRequest := &PaymentRequest{
        OrderID:     orderID,
        PayType:     payType,
        Status:      PaymentStatusInit,
        RequestTime: time.Now(),
    }
    if err := s.db.Create(paymentRequest).Error; err != nil {
        return err
    }

    // 执行支付
    strategy := s.factory.GetStrategy(payType)
    response, err := strategy.Pay(&PayRequest{OrderID: orderID})
    if err != nil {
        return err
    }

    // 更新支付请求
    paymentRequest.ThirdPartyID = response.ThirdPartyID
    paymentRequest.PayData = response.PayData
    return s.db.Save(paymentRequest).Error
}
```

```mermaid
graph LR
    A[支付请求] --> B[支付策略工厂];
    B --> C[微信支付策略];
    B --> D[支付宝支付策略];
    B --> E[银联支付策略];
    
    subgraph F [支付流程]
        C --> G[生成支付参数];
        D --> G;
        E --> G;
        G --> H[写入支付请求表];
        H --> I[调用支付网关];
        I --> J[更新支付状态];
    end
```

**流程图解释：**
- **策略模式**：通过工厂方法动态选择支付策略
- **开闭原则**：新增支付方式无需修改现有代码
- **双表设计**：支付请求表记录发起信息，回调表记录异步结果
- **状态追踪**：完整记录支付生命周期

## 3. 支付超时处理方案

### 方案一：扫表轮询实现

```go
type TimeoutScanner struct {
    db *gorm.DB
}

func (s *TimeoutScanner) ScanTimeoutOrders() {
    for {
        timeoutOrders := s.findTimeoutOrders()
        for _, order := range timeoutOrders {
            s.processTimeoutOrder(order)
        }
        time.Sleep(30 * time.Second) // 30秒扫描一次
    }
}

func (s *TimeoutScanner) processTimeoutOrder(order *Order) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查订单是否已支付
        if order.Status != OrderStatusPending {
            return nil
        }

        // 2. 更新订单状态为超时关闭
        if err := tx.Model(order).Update("status", OrderStatusTimeout).Error; err != nil {
            return err
        }

        // 3. 释放预占库存
        return s.inventoryService.ReleaseLockedInventory(tx, order.ID)
    })
}
```

```mermaid
graph TD
    A[定时任务启动] --> B[扫描超时订单];
    B --> C[获取待支付超时订单列表];
    C --> D[循环处理每个订单];
    D --> E{订单仍为待支付?};
    E -->|是| F[开启事务];
    E -->|否| G[跳过此订单];
    F --> H[更新订单状态为超时];
    H --> I[释放预占库存];
    I --> J[提交事务];
    J --> K[继续下一个订单];
    G --> K;
    K --> L{所有订单处理完成?};
    L -->|否| D;
    L -->|是| M[等待下次扫描];
```

### 方案二：延时队列实现

```go
type DelayQueueProcessor struct {
    mqClient MQClient
    db       *gorm.DB
}

func (p *DelayQueueProcessor) SubmitOrderTimeout(orderID uint, delay time.Duration) error {
    message := &TimeoutMessage{OrderID: orderID}
    return p.mqClient.SendDelayMessage("order_timeout", message, delay)
}

func (p *DelayQueueProcessor) HandleTimeoutMessage(message *TimeoutMessage) error {
    // 检查订单状态并处理超时
    var order Order
    if err := p.db.First(&order, message.OrderID).Error; err != nil {
        return err
    }
    
    if order.Status == OrderStatusPending {
        return p.processTimeoutOrder(&order)
    }
    return nil
}
```

```mermaid
sequenceDiagram
    participant C as 创建订单服务
    participant M as 消息队列
    participant P as 超时处理器
    participant D as 数据库

    C->>M: 发送延时消息(30分钟)
    Note over C,M: 订单创建时提交超时任务
    M-->>P: 消息到期触发
    P->>D: 查询订单当前状态
    alt 订单未支付
        P->>D: 开启事务
        P->>D: 更新订单状态为超时
        P->>D: 释放库存锁定
        P->>D: 提交事务
    else 订单已支付
        P->>P: 忽略此消息
    end
```

### 方案三：Redis过期实现

```go
type RedisTimeoutManager struct {
    redisClient *redis.Client
    db          *gorm.DB
}

func (m *RedisTimeoutManager) SetOrderTimeout(orderID uint, timeout time.Duration) error {
    key := fmt.Sprintf("order_timeout:%d", orderID)
    return m.redisClient.SetEX(key, orderID, timeout).Err()
}

// Redis配置键空间通知
func (m *RedisTimeoutManager) ListenTimeoutEvents() {
    pubsub := m.redisClient.Subscribe("__keyevent@0__:expired")
    for msg := range pubsub.Channel() {
        if strings.HasPrefix(msg.Payload, "order_timeout:") {
            orderID := extractOrderID(msg.Payload)
            go m.handleOrderTimeout(orderID)
        }
    }
}
```

```mermaid
graph TB
    A[创建订单] --> B[Redis.setex订单超时键];
    B --> C[30分钟自动过期];
    C --> D[Redis发布过期事件];
    D --> E[订阅者接收事件];
    E --> F[解析订单ID];
    F --> G[查询订单状态];
    G --> H{订单未支付?};
    H -->|是| I[处理超时逻辑];
    H -->|否| J[忽略事件];
    I --> K[释放库存];
    K --> L[更新订单状态];
    
    subgraph M [Redis Keyspace通知]
        C --> D
    end
```

## 4. 整体架构流程图

```mermaid
graph TB
    subgraph A [用户下单阶段]
        A1[用户提交订单] --> A2[GORM事务创建订单];
        A2 --> A3[预占库存];
        A3 --> A4[提交超时处理任务];
    end
    
    subgraph B [支付处理阶段]
        B1[选择支付方式] --> B2[策略工厂获取支付器];
        B2 --> B3[写入支付请求表];
        B3 --> B4[调用支付网关];
    end
    
    subgraph C [超时处理阶段]
        C1[扫表轮询] --> C2[批量处理超时订单];
        C3[延时队列] --> C4[精确单订单处理];
        C5[Redis过期] --> C6[事件驱动处理];
    end
    
    subgraph D [支付回调阶段]
        D1[支付平台回调] --> D2[验证签名];
        D2 --> D3[写入回调表];
        D3 --> D4[GORM事务更新状态];
        D4 --> D5[扣减真实库存];
        D4 --> D6[取消超时任务];
    end
    
    A4 --> C1
    A4 --> C3
    A4 --> C5
    B4 --> D1
```

**整体架构解释：**
- **数据一致性**：GORM事务保证关键操作的原子性
- **支付扩展性**：策略模式支持多种支付方式
- **超时容错**：三套方案适应不同业务规模
- **状态可追溯**：双表设计完整记录支付链路
- **库存安全**：预占机制防止超卖，超时自动释放

这样的设计既保证了系统的可靠性，又提供了良好的扩展性和性能表现。