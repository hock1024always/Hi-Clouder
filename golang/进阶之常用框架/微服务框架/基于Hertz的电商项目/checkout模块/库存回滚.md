##  Kafka å®ç°è®¢å•å¤±è´¥çš„åº“å­˜å›æ»š

### æ ¸å¿ƒæ¶æ„è®¾è®¡

```go
// åº“å­˜å›æ»šæœåŠ¡
type InventoryRollbackService struct {
    db         *gorm.DB
    kafkaProducer *kafka.Producer
    kafkaConsumer *kafka.Consumer
}

// è®¢å•å¤±è´¥æ¶ˆæ¯
type OrderFailedMessage struct {
    OrderID    uint      `json:"order_id"`
    UserID     uint      `json:"user_id"`
    FailedReason string  `json:"failed_reason"`
    FailedTime   time.Time `json:"failed_time"`
    Items       []OrderItem `json:"items"`
}
```

### 1. è®¢å•å¤±è´¥æ¶ˆæ¯ç”Ÿäº§ç«¯

```go
// è®¢å•æœåŠ¡ - å‘é€å¤±è´¥æ¶ˆæ¯
type OrderService struct {
    db           *gorm.DB
    kafkaProducer *kafka.Producer
}

func (s *OrderService) HandleOrderFailure(orderID uint, reason string) error {
    // æŸ¥è¯¢è®¢å•ä¿¡æ¯
    var order Order
    if err := s.db.Preload("Items").First(&order, orderID).Error; err != nil {
        return err
    }

    // æ„å»ºå¤±è´¥æ¶ˆæ¯
    message := &OrderFailedMessage{
        OrderID:     orderID,
        UserID:      order.UserID,
        FailedReason: reason,
        FailedTime:   time.Now(),
        Items:       order.Items,
    }

    // å‘é€åˆ°Kafka
    return s.sendToKafka(message)
}

func (s *OrderService) sendToKafka(message *OrderFailedMessage) error {
    jsonData, err := json.Marshal(message)
    if err != nil {
        return err
    }

    kafkaMessage := &kafka.Message{
        TopicPartition: kafka.TopicPartition{
            Topic:     &"order_failed",
            Partition: kafka.PartitionAny,
        },
        Value: jsonData,
        Key:   []byte(fmt.Sprintf("order_%d", message.OrderID)),
    }

    return s.kafkaProducer.Produce(kafkaMessage, nil)
}
```

```mermaid
graph TD
    A[è®¢å•åˆ›å»ºå¤±è´¥] --> B[æŸ¥è¯¢è®¢å•è¯¦æƒ…];
    B --> C[æ„å»ºå¤±è´¥æ¶ˆæ¯];
    C --> D[åºåˆ—åŒ–JSON];
    D --> E[å‘é€Kafkaæ¶ˆæ¯];
    E --> F[Kafka Topic: order_failed];
    F --> G[åˆ†åŒºé€‰æ‹©];
    G --> H[æŒ‰è®¢å•IDåˆ†åŒº];
    
    subgraph I [æ¶ˆæ¯ç»“æ„]
        J[OrderID] --> K[UserID];
        K --> L[FailedReason];
        L --> M[FailedTime];
        M --> N[Items];
    end
```

**æµç¨‹å›¾è§£é‡Šï¼š**
- è®¢å•å¤±è´¥æ—¶ç«‹å³å‘é€æ¶ˆæ¯åˆ° Kafka
- ä½¿ç”¨è®¢å•IDä½œä¸ºKeyä¿è¯åŒä¸€è®¢å•æ¶ˆæ¯è¿›å…¥åŒä¸€åˆ†åŒº
- æ¶ˆæ¯åŒ…å«å®Œæ•´çš„è®¢å•ä¿¡æ¯å’Œå¤±è´¥åŸå› 
- å¼‚æ­¥å¤„ç†ï¼Œä¸å½±å“ä¸»ä¸šåŠ¡æµç¨‹

### 2. åº“å­˜å›æ»šæ¶ˆæ¯æ¶ˆè´¹ç«¯

```go
// åº“å­˜å›æ»šæ¶ˆè´¹è€…
type InventoryRollbackConsumer struct {
    db           *gorm.DB
    kafkaConsumer *kafka.Consumer
}

func (c *InventoryRollbackConsumer) StartConsumer() {
    c.kafkaConsumer.SubscribeTopics([]string{"order_failed"}, nil)
    
    for {
        msg, err := c.kafkaConsumer.ReadMessage(-1)
        if err != nil {
            log.Printf("Consumer error: %v", err)
            continue
        }
        
        go c.processMessage(msg)
    }
}

func (c *InventoryRollbackConsumer) processMessage(msg *kafka.Message) error {
    var failedMessage OrderFailedMessage
    if err := json.Unmarshal(msg.Value, &failedMessage); err != nil {
        return err
    }

    return c.db.Transaction(func(tx *gorm.DB) error {
        // æ£€æŸ¥è®¢å•çŠ¶æ€ï¼Œé¿å…é‡å¤å¤„ç†
        var order Order
        if err := tx.First(&order, failedMessage.OrderID).Error; err != nil {
            return err
        }
        
        if order.Status != OrderStatusFailed {
            // è®¢å•å¯èƒ½å·²è¢«å…¶ä»–æµç¨‹å¤„ç†ï¼Œè·³è¿‡
            return nil
        }

        // æ‰§è¡Œåº“å­˜å›æ»š
        if err := c.rollbackInventory(tx, failedMessage.Items); err != nil {
            return err
        }

        // æ›´æ–°è®¢å•å›æ»šçŠ¶æ€
        order.RollbackStatus = RollbackStatusCompleted
        order.RollbackTime = time.Now()
        return tx.Save(&order).Error
    })
}

func (c *InventoryRollbackConsumer) rollbackInventory(tx *gorm.DB, items []OrderItem) error {
    for _, item := range items {
        // é‡Šæ”¾é¢„å åº“å­˜
        if err := tx.Exec(`
            UPDATE inventory 
            SET locked_quantity = locked_quantity - ?, 
                available_quantity = available_quantity + ? 
            WHERE product_id = ? AND locked_quantity >= ?`,
            item.Quantity, item.Quantity, item.ProductID, item.Quantity).Error; err != nil {
            return err
        }
        
        // è®°å½•åº“å­˜å›æ»šæ—¥å¿—
        inventoryLog := &InventoryLog{
            ProductID:  item.ProductID,
            OrderID:    item.OrderID,
            ChangeType: "rollback",
            Quantity:   item.Quantity,
            CreatedAt:  time.Now(),
        }
        if err := tx.Create(inventoryLog).Error; err != nil {
            return err
        }
    }
    return nil
}
```

```mermaid
sequenceDiagram
    participant K as Kafka
    participant C as åº“å­˜æ¶ˆè´¹è€…
    participant D as æ•°æ®åº“
    participant L as æ—¥å¿—ç³»ç»Ÿ

    K->>C: æ¨é€è®¢å•å¤±è´¥æ¶ˆæ¯
    C->>D: å¼€å¯äº‹åŠ¡
    C->>D: æŸ¥è¯¢è®¢å•å½“å‰çŠ¶æ€
    alt è®¢å•çŠ¶æ€ä¸ºå¤±è´¥
        C->>D: å¾ªç¯é‡Šæ”¾æ¯ä¸ªå•†å“åº“å­˜
        C->>D: locked_quantity - quantity
        C->>D: available_quantity + quantity
        C->>D: å†™å…¥åº“å­˜å›æ»šæ—¥å¿—
        C->>D: æ›´æ–°è®¢å•å›æ»šçŠ¶æ€
        C->>D: æäº¤äº‹åŠ¡
        C->>L: è®°å½•å›æ»šæˆåŠŸæ—¥å¿—
    else è®¢å•çŠ¶æ€éå¤±è´¥
        C->>D: å›æ»šäº‹åŠ¡
        C->>L: è®°å½•è·³è¿‡å¤„ç†æ—¥å¿—
    end
    C->>K: æäº¤æ¶ˆè´¹ä½ç§»
```

### 3. æ¶ˆè´¹è€…ç»„ä¸å®¹é”™æœºåˆ¶

```go
// æ¶ˆè´¹è€…ç»„é…ç½®
type ConsumerGroupConfig struct {
    GroupID           string
    Topics            []string
    SessionTimeout    time.Duration
    HeartbeatInterval time.Duration
    AutoOffsetReset   string
    EnableAutoCommit  bool
}

func (c *InventoryRollbackConsumer) setupConsumerGroup() {
    config := &kafka.ConfigMap{
        "bootstrap.servers":  "kafka1:9092,kafka2:9092",
        "group.id":           "inventory-rollback-group",
        "auto.offset.reset":  "earliest",
        "enable.auto.commit": false, // æ‰‹åŠ¨æäº¤ä½ç§»
        "session.timeout.ms": 6000,
    }
    
    consumer, err := kafka.NewConsumer(config)
    if err != nil {
        log.Fatal("Failed to create consumer:", err)
    }
}

// é‡è¯•æœºåˆ¶
func (c *InventoryRollbackConsumer) processMessageWithRetry(msg *kafka.Message) {
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        err := c.processMessage(msg)
        if err == nil {
            // å¤„ç†æˆåŠŸï¼Œæäº¤ä½ç§»
            c.kafkaConsumer.CommitMessage(msg)
            return
        }
        
        if i == maxRetries-1 {
            // æœ€ç»ˆå¤±è´¥ï¼Œå‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
            c.sendToDLQ(msg, err)
            c.kafkaConsumer.CommitMessage(msg)
        } else {
            // é‡è¯•
            time.Sleep(time.Duration(i+1) * time.Second)
        }
    }
}

// æ­»ä¿¡é˜Ÿåˆ—å¤„ç†
func (c *InventoryRollbackConsumer) sendToDLQ(msg *kafka.Message, err error) {
    dlqMessage := &DLQMessage{
        OriginalMessage: msg.Value,
        Error:           err.Error(),
        FailedTime:      time.Now(),
    }
    
    dlqData, _ := json.Marshal(dlqMessage)
    kafkaMessage := &kafka.Message{
        TopicPartition: kafka.TopicPartition{Topic: &"order_failed_dlq", Partition: kafka.PartitionAny},
        Value:          dlqData,
    }
    c.kafkaProducer.Produce(kafkaMessage, nil)
}
```

```mermaid
graph TB
    A[æ¶ˆè´¹Kafkaæ¶ˆæ¯] --> B[è§£ææ¶ˆæ¯å†…å®¹];
    B --> C[å¼€å¯æ•°æ®åº“äº‹åŠ¡];
    C --> D[æ£€æŸ¥è®¢å•çŠ¶æ€];
    D --> E{è®¢å•éœ€è¦å›æ»š?};
    E -->|æ˜¯| F[æ‰§è¡Œåº“å­˜å›æ»š];
    E -->|å¦| G[è·³è¿‡å¤„ç†];
    F --> H[æ›´æ–°è®¢å•å›æ»šçŠ¶æ€];
    H --> I[æäº¤äº‹åŠ¡];
    I --> J[æäº¤Kafkaä½ç§»];
    J --> K[å¤„ç†æˆåŠŸ];
    
    F --> L[å›æ»šå¤±è´¥];
    L --> M{é‡è¯•æ¬¡æ•°<3?};
    M -->|æ˜¯| N[ç­‰å¾…é‡è¯•];
    N --> F;
    M -->|å¦| O[å‘é€æ­»ä¿¡é˜Ÿåˆ—];
    O --> J;
    
    subgraph P [å®¹é”™æœºåˆ¶]
        Q[é‡è¯•æœºåˆ¶] --> R[æ­»ä¿¡é˜Ÿåˆ—];
        R --> S[äººå·¥å¹²é¢„];
        T[ä½ç§»æ‰‹åŠ¨æäº¤] --> U[é¿å…æ¶ˆæ¯ä¸¢å¤±];
    end
```

### 4. ç›‘æ§ä¸å‘Šè­¦

```go
// ç›‘æ§æŒ‡æ ‡
type MetricsCollector struct {
    rollbackSuccess prometheus.Counter
    rollbackFailure prometheus.Counter
    processingTime  prometheus.Histogram
    dlqMessages     prometheus.Counter
}

func (c *InventoryRollbackConsumer) processWithMetrics(msg *kafka.Message) {
    startTime := time.Now()
    
    err := c.processMessage(msg)
    
    if err != nil {
        c.metrics.rollbackFailure.Inc()
        log.Error("åº“å­˜å›æ»šå¤±è´¥", "order_id", msg.Key, "error", err)
    } else {
        c.metrics.rollbackSuccess.Inc()
        c.metrics.processingTime.Observe(time.Since(startTime).Seconds())
    }
}
```

### æ–¹æ¡ˆä¼˜åŠ¿æ€»ç»“

**å¯é æ€§ä¿è¯ï¼š**
- âœ… **æ¶ˆæ¯æŒä¹…åŒ–**ï¼šKafkaä¿è¯æ¶ˆæ¯ä¸ä¸¢å¤±
- âœ… **é¡ºåºæ€§ä¿è¯**ï¼šåŒä¸€è®¢å•æ¶ˆæ¯è¿›å…¥åŒä¸€åˆ†åŒº
- âœ… **é‡è¯•æœºåˆ¶**ï¼šè‡ªåŠ¨é‡è¯•+æ­»ä¿¡é˜Ÿåˆ—å…œåº•
- âœ… **äº‹åŠ¡ä¸€è‡´æ€§**ï¼šæ•°æ®åº“äº‹åŠ¡ä¿è¯åº“å­˜å›æ»šåŸå­æ€§

**æ€§èƒ½ä¼˜åŠ¿ï¼š**
- ğŸš€ **å¼‚æ­¥å¤„ç†**ï¼šä¸å½±å“ä¸»è®¢å•æµç¨‹æ€§èƒ½
- ğŸš€ **æ‰¹é‡èƒ½åŠ›**ï¼šKafkaé«˜ååæ”¯æŒ
- ğŸš€ **æ°´å¹³æ‰©å±•**ï¼šæ¶ˆè´¹è€…ç»„æ”¯æŒå¤šå®ä¾‹éƒ¨ç½²

**è¿ç»´å‹å¥½ï¼š**
- ğŸ”§ **ç›‘æ§å®Œå–„**ï¼šå…³é”®æŒ‡æ ‡ç›‘æ§å’Œå‘Šè­¦
- ğŸ”§ **å®¹é”™æ€§å¼º**ï¼šå•ç‚¹æ•…éšœä¸å½±å“æ•´ä½“ç³»ç»Ÿ
- ğŸ”§ **å¯è¿½æº¯**ï¼šå®Œæ•´æ—¥å¿—è®°å½•å’Œæ­»ä¿¡é˜Ÿåˆ—

è¿™æ ·çš„è®¾è®¡æ–¹æ¡ˆæ—¢ä¿è¯äº†åº“å­˜å›æ»šçš„å¯é æ€§ï¼Œåˆæä¾›äº†è‰¯å¥½çš„æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚