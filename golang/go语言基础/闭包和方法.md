# 函数编程

## 声明式返回

```go
func Sum(a, b int) (sum int, err error) {
	if a < 0 && b < 0 {
		err = errors.New("a and b must be positive")
		return 0, err
	}
	sum = a + b
	return
}
```

## 函数签名

通过定义一个函数的类型来实现函数签名

```go
type SumFunc func(a, b int) (int, error)
```

使用如下

```go
//函数赋值给变量
	f1 := _case.Sum// var f1 _case.SumFunc =  _case.Sum
	fmt.Println(f1(1, 2))
```

## 高阶函数

**函数中间件（Middleware）** 的经典实现模式，它通过 **闭包（Closure）** 和 **函数类型（Type Alias）** 的组合，在不修改原函数逻辑的情况下，为其添加了日志功能。

```go
// 将函数作为输入输出的实现中间件
func LogMiddleware(in SumFunc) SumFunc {
	//返回的函数为闭包函数
	return func(a, b int) (int, error) {
		log.Printf("日志中间件，记录操作数： a:%d b:%d", a, b)
		return in(a, b)
	}
}
```

使用如下

```go
//	将函数作为输入输出中间件
	f2 := _case.LogMiddleware(_case.Sum)//var f2 _case.SumFunc = _case.LogMiddleware(_case.Sum)
	//再次申请中间件
	fmt.Println(f2(1, 2))
```

会打印出

```go
3 <nil>
2025/07/09 23:57:24 日志中间件，记录操作数： a:1 b:2
```

## 函数的强制类型转化

```go
f3 := _case.SumFunc(f1)//var f3 _case.SumFunc = _case.SumFunc(f1)
```

## 中间件方式与类型转化方式的区别

强制类型转化和中间件方式实例化出的变量类型是一样的，但是在调用的时候会有一些不同,我们就拿下面这个函数举例子

```go
//关键点
//函数作为参数和返回值（高阶函数特性）：
//Go 中函数是一等公民，可以像变量一样传递。
//LogMiddleware 接收一个函数 in，并返回一个增强后的函数。
//闭包（Closure）：
//返回的函数是一个闭包，捕获了外部函数的 in，因此可以调用原始函数。
//装饰器模式：
//不修改 in 的逻辑，而是通过包装添加额外功能（日志记录） 。
// 声明receiver为函数类型的方法，即函数类型的对象的方法
func (sum SumFunc) Accumulation(list ...int) (int, error) {
	s := 0
	var err error
	for _, i := range list {
		s, err := sum(s, i)
		if err != nil {
			return s, err
		}
	}
	return s, err
}
```

### 类型转化的调用结果

```go
fmt.Println(f3.Accumulation(1, 2, 3, 4))
```

运行结果：

```
0 <nil>
```

### 中间件方式的调用结果

```go
fmt.Println(f2.Accumulation(1, 2, 3, 4, 5))
```

运行结果：

```go
0 <nil>
2025/07/10 00:11:50 日志中间件，记录操作数： a:0 b:1
2025/07/10 00:11:50 日志中间件，记录操作数： a:0 b:2
2025/07/10 00:11:50 日志中间件，记录操作数： a:0 b:3
2025/07/10 00:11:50 日志中间件，记录操作数： a:0 b:4
2025/07/10 00:11:50 日志中间件，记录操作数： a:0 b:5
```

如果`f3`是`f3 := _case.SumFunc(f2)`这样声明的，其依旧具备打印日志的属性

## main函数总代码

```go
func main() {
	//调用函数
	fmt.Println(_case.Sum(1, 2))
	//函数赋值给变量
	f1 := _case.Sum
	fmt.Println(f1(1, 2))

	//	将函数作为输入输出中间件
	f2 := _case.LogMiddleware(_case.Sum)
	//再次申请中间件
	fmt.Println(f2(1, 2))
	f3 := _case.SumFunc(f1)
	fmt.Println(f3.Accumulation(1, 2, 3, 4))
	fmt.Println(f2.Accumulation(1, 2, 3, 4, 5))

	fmt.Println(_case.Fib(10))

	_case.ClosureTrap()
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, os.Kill)
	defer cancel()
	<-ctx.Done()
}
```

# 闭包

## 闭包的简单使用

```go
func counter() func() int {
    count := 0
    return func() int {
        count++ // 引用了外部变量 count
        return count
    }
}

func main() {
    c := counter() // 返回一个闭包
    fmt.Println(c()) // 1
    fmt.Println(c()) // 2
    fmt.Println(c()) // 3
}
```

匿名函数 引用了外部变量 count，即使 counter() 已经执行完毕，count 仍然被闭包持有。

正常情况下，函数结束的时候变量count的生命周期就结束了，但是使用闭包返回的类型c会维持住这个count变量，使其生命周期和c一样，在counter()函数结束之后依旧存在

## 使用闭包实现斐波那契

```go
func Fib(n int) int {
	if n <= 2 {
		log.Fatal("n must be greater than 2")
	}
	t := tool()
	var res int
	for i := 0; i < n-2; i++ {
		res = t()
	}
	return res
}

// 斐波那契数列，X0+X1+X2+...+Xn-1 = Xn
func tool() func() int {
	var x0 = 0
	var x1 = 1
	var x2 = 0
	return func() int {
		x2 = x0 + x1
		x0 = x1
		x1 = x2
		return x2
	}
}

func ClosureTrap() {
	/*错误的方式
	for i := 0; i < 10; i++ {
		go func() {
			log.Println(i)
		}()
	}
	*/
	for i := 0; i < 10; i++ {
		go func(j int) {
			log.Println(j)
		}(i)
	}
}
```

## 闭包陷阱

### 引用传递

```go
for i := 0; i < 10; i++ {
    go func() {
        log.Println(i)  // ❌ 捕获循环变量i的引用
    }()
}
```

**问题本质**

1. **共享变量**：所有 goroutine 共享同一个 `i` 的引用（内存地址）
2. **竞态条件**：当 goroutine 执行 `log.Println(i)` 时，`i` 的值可能已被循环更新

goroutine 启动需要时间，循环可能先执行完毕（`i` 最终变为 10）

### 值传递

```go
for i := 0; i < 10; i++ {
    go func(j int) {  // ✅ 通过参数传递值
        log.Println(j)
    }(i)  // 传递当前i的值
}
```

**正确原理**

1. **值拷贝**：每次循环将 `i` 的值拷贝到参数 `j`（每个 goroutine 有自己的 `j` 副本）
2. **隔离性**：每个 goroutine 操作独立的 `j`，不受后续循环影响