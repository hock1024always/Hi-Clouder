# 接口

1. 接口（interface）用于定义行为的集合，它通过描述类型**必须实现的方法**
2. 只要一个类型实现了接口要求的**所有方法**，该类型就自动被认为实现了该接口
3. 接口变量包含了两个部分，**动态类型**(存储实际的值类型),**动态值**(存储具体的值)
4. 接口的零值是 `nil`；空接口定义为 `interface{}`，可以表示任何类型
5. 接口常见的用法有**多态**（不同类型实现同一接口）,**解耦**（通过接口定义依赖关系，一般是使用接口绑定方法），**泛化**（使用空接口 `interface{}` 表示任意类型）

## 定义与实现

### 接口的定义

下面举得例子是没有限制类型的接口方法

```go
type Playground interface {
	Area()
	Perimeter()
}
```

除此之外，如果想要明确指明类型的话，可以采用下面的定义方式（这个float64限制的是返回值的类型）

```go
type Shape interface {
	Area() float64
	Perimeter() float64
}
```

### 接口方法的实现

```go
type football_ground struct {
	length float64
	width  float64
}

// 实现接口
func (f football_ground) Area()  {}
func (f football_ground) Perimeter()  {}
```

### 接口方法的使用

```go
type football_ground struct {
	length float64
	width  float64
}

// 实现接口
func (f football_ground) Area() float64 {
	return f.length * f.width
}

func (f football_ground) Perimeter() float64 {
	return 2 * (f.length + f.width)
}
func main() {
	f := football_ground{length: 100, width: 50}
	fmt.Println(f.Area())
	fmt.Println(f.Perimeter())
}
```

## 空接口

任意类型都实现了空接口，其常用于需要**存储任意类型数据的场景**，如泛型容器、通用参数

```go
func printValue(val interface{}) {
        fmt.Printf("Value: %v, Type: %T\n", val, val)
}

func main() {
        printValue(42)         // int
        printValue("hello")    // string
        printValue(3.14)       // float64
        printValue([]int{1, 2}) // slice
}
```

## 类型断言

类型断言用于从接口类型中提取其底层值，判断其类型是否是...。

### 基本用法

`value := iface.(Type)`

- `iface` 是接口变量。
- `Type` 是要断言的具体类型。
- 如果类型不匹配，会触发 `panic`。

```go
func main() {
        var i interface{} = "hello"
        str := i.(string) // 类型断言 如果类型不是string就回panic
        fmt.Println(str)  // 输出：hello
}
```

### 带检查的类型断言

这个是为了避免panic

`value, ok := iface.(Type)`

- `ok` 是一个布尔值，表示断言是否成功。
- 如果断言失败，`value` 为零值，`ok` 为 `false`。

```go
func main() {
        var i interface{} = 42
        if str, ok := i.(string); ok {
                fmt.Println("String:", str)
        } else {
                fmt.Println("Not a string")
        }
}
```

### 类型选择

```go
func printType(val interface{}) {
        switch v := val.(type) {
        case int:
                fmt.Println("Integer:", v)
        case string:
                fmt.Println("String:", v)
        case float64:
                fmt.Println("Float:", v)
        default:
                fmt.Println("Unknown type")
        }
}

func main() {
        printType(42)
        printType("hello")
        printType(3.14)
        printType([]int{1, 2, 3})
}
```

## 接口组合

这个就相当于是将将两个接口的方法整合到一个接口中

```go
type Reader interface {
	Read() string
}

type Writer interface {
	Write(data string)
}

type ReadWriter interface {
	Reader
	Writer
}

type File struct{}

func (f File) Read() string {
	return "Reading data"
}

func (f File) Write(data string) {
	fmt.Println("Writing data:", data)
}

func main() {
	var rw ReadWriter = File{}
	fmt.Println(rw.Read())
	rw.Write("Hello, Go!")
}
```

## 动态值和动态类型

这部分对接口变量进行拆分(其实就是接口会隐式的存储)：

- **动态类型**：接口变量存储的具体类型。

- **动态值**：具体类型的值。

```go
	var i interface{} = 42
    fmt.Printf("Dynamic type: %T, Dynamic value: %v\n", i, i)

	//执行上述代码的输出结果
	//Dynamic type: int, Dynamic value: 42
```

### 零值

当接口变量的动态类型和动态值都为 nil 时，接口变量为 nil

```go
func main() {
        var i interface{}
        fmt.Println(i == nil) // 输出：true
}
```

## 实际用法

下面这段代码是对接口方法的最常见应用，本质上就是不同结构体调用自己的方法（接口是用来统一这两个结构体的）

```go
type Shape interface {
    area() float64
}

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) area() float64 {
    return r.width * r.height
}

type Circle struct {
    radius float64
}

func (c Circle) area() float64 {
    return 3.14 * c.radius * c.radius
}

func main() {
    var s Shape

    s = Rectangle{width: 10, height: 5}
    fmt.Printf("矩形面积: %f\n", s.area())

    s = Circle{radius: 3}
    fmt.Printf("圆形面积: %f\n", s.area())
}
```

# 结构体

## 定义与声明

```go
//结构体的定义
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}

//声明1：隐式声明
variable_name := structure_variable_type {value1, value2...valuen}
//声明2：显示声明
variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}
```

## 结构体成员

不用看下面这一大段代码，访问结构体成员的方法就两部

1. 要有成员：必须实例化这个结构体为对象` var Book1 Books`
2. 使用`.` 的方式去访问：`Book1.title = "Go 语言"`

```go
type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = "Go 语言"
   Book1.author = "www.runoob.com"
   Book1.subject = "Go 语言教程"
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = "Python 教程"
   Book2.author = "www.runoob.com"
   Book2.subject = "Python 语言教程"
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   fmt.Printf( "Book 1 title : %s\n", Book1.title)
   fmt.Printf( "Book 1 author : %s\n", Book1.author)
   fmt.Printf( "Book 1 subject : %s\n", Book1.subject)
   fmt.Printf( "Book 1 book_id : %d\n", Book1.book_id)

   /* 打印 Book2 信息 */
   fmt.Printf( "Book 2 title : %s\n", Book2.title)
   fmt.Printf( "Book 2 author : %s\n", Book2.author)
   fmt.Printf( "Book 2 subject : %s\n", Book2.subject)
   fmt.Printf( "Book 2 book_id : %d\n", Book2.book_id)
   
   //下面这个方法会在下面进行对比重写
   /* 打印 Book1 信息 */
   printBook(Book1)
   /* 打印 Book2 信息 */
   printBook(Book2)
}

func printBook( book Books ) {
   fmt.Printf( "Book title : %s\n", book.title)
   fmt.Printf( "Book author : %s\n", book.author)
   fmt.Printf( "Book subject : %s\n", book.subject)
   fmt.Printf( "Book book_id : %d\n", book.book_id)
}
```

## 结构体指针

除了引用成员变量之外和c语言很类似

1. 定义指向结构体的指针类似于其他指针变量，格式如下：`var struct_pointer *Books`
2. 查看结构体变量地址，可以将 & 符号放置于结构体变量前：`struct_pointer = &Book1`
3. 结构体指针访问结构体成员，使用 "." 操作符：`struct_pointer.title`

```go
//使用结构体指针的方法对上述printBook方法进行重写
/* 打印 Book1 信息 */
printBook(&Book1)
func printBook( book *Books ) {
   fmt.Printf( "Book title : %s\n", book.title)
   fmt.Printf( "Book author : %s\n", book.author)
   fmt.Printf( "Book subject : %s\n", book.subject)
   fmt.Printf( "Book book_id : %d\n", book.book_id)
}
```

# 泛型

go从1.18版本之后引入“泛型”这一概念

## 基础内容

1. 用于处理 **不同**数据**类型** **同一逻辑**功能 的应用场景，可以简化代码但是降低了编译的效率
2. 有 泛型函数，泛型类型，泛型接口，泛型结构体，泛型 receiver 这几个
3. 匿名函数与结构体不支持泛型(不支持定义但是支持使用)，不支持类型断言，不支持泛型方法（只能通过receiver来实现），泛型后的类型必须要为基本类型(不能为接口类型)

## 代码示例

### 泛型函数(方法)

泛型方法不一样的地方就在于`[T int | float64]`在传入参数之前有一个**适用类型的枚举**，之后使用`T`作为新的类型

```go
func getMaxNumInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func getMaxNumFlout(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

// 使用泛型实现比较大小的方法
func getMaxNum[T int | float64](a, b T) T {
	if a > b {
		return a
	}
	return b
}

func main() {
	//正常方法
	fmt.Println(getMaxNumInt(10, 20))
	fmt.Println(getMaxNumFlout(10.5, 20.5))
	println(getMaxNumFlout(10.5, 20.5))
	
	//泛型方法
    fmt.Println(getMaxNum(10, 20), getMaxNum(10.5, 20.5))//编译器推断
	fmt.Println(getMaxNum[int](10, 20), getMaxNum[float64](10.5, 20.5))//显式指出
}
```

### 泛型结构体和接口

下面是使用泛型结构体来实现的这个方法，首先是要注意必须绑定方法和结构体，其次是要注意使用方法时必须实例化结构体

```go
comparable  //可以进行大小比较的类型
any   //任何类型
```

```go
type MyType[T interface{ int | float64 }] struct {
	value T
}

func (m MyType[T]) GetMaxNumByMyType(a, b T) T {
	if a > b {
		return a
	}
	return b
}
```

泛型接口相当于是一个新定义的类型，但是这个类型只能用来约束变量类型，不能实例化

### 泛型Receiver

即这个方法的所有者是一个泛型类型

```go
type MyStruct[T interface{ *int | *string }] struct {
	Name string
	Data T
}

// 泛型receiver
// 泛型方法示例
func (myStruct MyStruct[T]) GetData() T {
	//var i interface{} = 10
	//a, ok := i.(int)
	//b, ok := t.(int)
	return myStruct.Data
}

type Top[T comparable] interface {
	any
	GetData() T
}

func ReceiverCase() {
	data := 18
	myStruct := MyStruct[*int]{
		Name: "jack",
		Data: &data,
	}
	data1 := myStruct.GetData()
	fmt.Println("泛型receiver", data1)

	str := "hello"
	myStruct1 := MyStruct[*string]{
		Name: "jack",
		Data: &str,
	}
	str1 := myStruct1.GetData()
	fmt.Println("泛型receiver", str1)
}
```

### 别名类型与衍生类型

```go
type CusNumT interface {
	int32 | uint8 | float64 | ~int64 // ~ 代表某个类型及其衍生类型
}
type MyInt64 int64 //衍生类型，是具有基础类型int64的新类型，与int64不是同一类型
type MyInt32 = int32 //别名类型，与int32是同一类型
```

```go
func getMaxNum[T int | float64](a, b T) T {
	if a > b {
		return a
	} else {
		return b
	} // return a > b ? a : b
}

type CusNumT interface {
	int32 | uint8 | float64 | ~int64 // ~ 代表某个类型及其衍生类型
}
type MyInt64 int64 //衍生类型，是具有基础类型int64的新类型，与int64不是同一类型

type MyInt32 = int32 //别名类型，与int32是同一类型

func getMaxCusNum[T CusNumT](a, b T) T {
	if a > b {
		return a
	} else {
		return b
	} // return a > b ? a : b
}

func CusNumTCase() {
	var a, b MyInt32 = 3, 4
	var a1, b1 int32 = 5, 6
	fmt.Println("自定义泛型，数字比较", getMaxCusNum(a, b))
	fmt.Println("自定义泛型，数字比较", getMaxCusNum(a1, b1))
}

// 内置类型
func BuiltInCase() {
	var a, b string = "abc", "def"
	fmt.Println("内置comparable类型约束", getBuiltInComparable(a, b))
	fmt.Println("内置any类型约束", printBuiltInAny(a, b))
	var c, d float64 = 1.3, 1.7
	fmt.Println("内置comparable类型约束", getBuiltInComparable(c, d))
}
func getBuiltInComparable[T comparable](a, b T) bool {
	//comparable是内置接口，表示可比较的类型(支持==  ！=的类型)，如int、float、string等
	if a == b {
		return true
	}
	return false
}

func printBuiltInAny[T any](a, b T) bool {
	//any是内置接口，表示任意类型
	fmt.Println(a, b)
	return true
}
```

### 泛型切片、Map和channel

1. 泛型Map的**键和值**都可以是 **泛型类型**
2. 泛型slice的**元素**都可以是 泛型类型
3. 泛型Channel中**传输的元素**可以是 泛型类型

```go
type user struct {
	ID   int64
	Name string
	Age  uint8
}
type address struct {
	ID       int
	Province string
	City     string
}

// map（集合）转slice（切片）
func mapTolist[k comparable, T any](mp map[k]T) []T {
	list := make([]T, len(mp))
	var i int
	for _, data := range mp {
		list[i] = data
		i++
	}
	return list
}

func myPrintln[T any](ch chan T) {
	for data := range ch {
		fmt.Println(data)
	}
}

func TTypeCase() {
	// 创建一个map，键为int64类型，值为user类型
	userMp := make(map[int64]user)
	// 向map中添加两个user类型的值
	userMp[1] = user{ID: 1, Name: "张三", Age: 18}
	userMp[2] = user{ID: 2, Name: "李四", Age: 19}
	// 将map转换为list
	userList := mapTolist[int64, user](userMp)

	ch := make(chan user)
	// 创建一个Chan类型的变量
	//var ch Chan[user]
	// 启动一个goroutine，用于打印Chan中的值
	go myPrintln(ch)
	// 遍历userList，将每个user类型的值发送到Chan中
	for _, u := range userList {
		ch <- u
	}
	// 创建一个map，键为int类型，值为address类型
	addrMp := make(map[int]address)
	// 向map中添加两个address类型的值
	addrMp[1] = address{ID: 1, Province: "北京", City: "北京"}
	addrMp[2] = address{ID: 2, Province: "上海", City: "上海"}
	// 将map转换为list
	addrList := mapTolist[int, address](addrMp)

	// 创建一个Chan类型的变量
	ch1 := make(chan address)
	// 启动一个goroutine，用于打印Chan中的值
	go myPrintln(ch1)
	// 遍历addrList，将每个address类型的值发送到Chan中
	for _, addr := range addrList {
		ch1 <- addr
	}
}

// 泛型切片的定义
type List[T any] []T

// 泛型定义map
type MapT[k comparable, v any] map[k]v

// 泛型定义channel通道
type Chan[T any] chan T
```

# 继承

Go 语言没有传统面向对象语言中的类(class)和继承(inheritance)概念，而是通过**组合**(composition)和**接口**(interface)来实现类似的功能

## 组合

组合是 Go 中实现代码复用的主要方式。通过将一个结构体嵌入到另一个结构体中，子结构体可以"继承"父结构体的字段和方法

```go
// 父结构体
type Animal struct {
    Name string
}

// 父结构体的方法
func (a *Animal) Speak() {
    fmt.Println(a.Name, "says hello!")
}

// 子结构体
type Dog struct {
    Animal // 嵌入 Animal 结构体
    Breed  string
}

func main() {
    dog := Dog{
        Animal: Animal{Name: "Buddy"},
        Breed:  "Golden Retriever",
    }

    dog.Speak() // 调用父结构体的方法
    fmt.Println("Breed:", dog.Breed)
}
```

## 接口

接口是 Go 中实现多态的主要方式。通过定义接口，不同的结构体可以实现相同的方法，从而实现类似继承的多态行为。

```go
type Speaker interface {
    Speak()
}

// 父结构体
type Animal struct {
    Name string
}

// 实现接口方法
func (a *Animal) Speak() {
    fmt.Println(a.Name, "says hello!")
}

// 子结构体
type Dog struct {
    Animal
    Breed string
}

func main() {
    var speaker Speaker

    dog := Dog{
        Animal: Animal{Name: "Buddy"},
        Breed:  "Golden Retriever",
    }

    speaker = &dog
    speaker.Speak() // 通过接口调用方法
}
```

值得注意的是，下面这种写法也是不报错的

```go
dog := Dog{
		Animal: Animal{Name: "Buddy"},
		Breed:  "Golden Retriever",
	}
	dog.Speak() // 通过接口调用方法
```

1. 某个类型的值类型方法可以被指针类型来调用（因为有指针肯定可以找到值），也就是说值类型实现的方法，指针类型也就算实现了
2. 但是指针类型的方法不一定能被值方法去调用（为什么是不一定而不是不？这是因为go中的语法糖可以隐式的转换一些情况下的值，当其可以寻址的时候）

## 完整基础模型

```go
// 基类
type Vehicle struct {
    Brand string
}

func (v *Vehicle) Start() {
    fmt.Println(v.Brand, "started")
}

// 派生类
type Car struct {
    Vehicle // 嵌入Vehicle
    Model  string
}

// 重写Start方法
func (c *Car) Start() {
    fmt.Println(c.Brand, c.Model, "car started")
}

func main() {
    v := Vehicle{Brand: "Toyota"}
    c := Car{
        Vehicle: Vehicle{Brand: "Honda"},
        Model:  "Civic",
    }
   
    v.Start() // Toyota started
    //注意一下下面两个方法的调用方式和结果，就明白了go继承
    c.Start() // Honda Civic car started
    c.Vehicle.Start() // Honda started  
}
```

# 断言

在 Go 语言中，类型断言（Type Assertion）是一种用于检查**接口值**的实际类型的机制

## 断言形式

### 基本形式

类型断言的基本语法：`value, ok := interfaceValue.(Type)`

- `interfaceValue` 是一个接口类型的变量。
- `Type` 是你想要断言的类型。
- `value` 是断言成功后的具体类型的值。
- `ok` 是一个布尔值，表示断言是否成功。

如果断言成功，`value` 将是 `interfaceValue` 的实际值，`ok` 为 `true`；如果断言失败，`value` 将是 `Type` 的零值，`ok` 为 `false`。

### 引发panic形式

`value := interfaceValue.(Type)`

```go
func main() {
    var i interface{} = "Hello, Go!"

    // 直接断言为 string 类型
    s := i.(string)
    fmt.Println("断言成功:", s)

    // 直接断言为 int 类型（会引发 panic）
    n := i.(int)
    fmt.Println("断言成功:", n)
}
```

### Switch形式

Go 还提供了特殊的 **type switch** 语法来测试多种类型：

```go
switch v := i.(type) {
case T1:
    // v的类型是T1
case T2:
    // v的类型是T2
default:
    // 默认情况
}
```

## 断言用途

### 根据不同类型的值进行不同操作

```go
func printType(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Println("这是一个整数:", v)
    case string:
        fmt.Println("这是一个字符串:", v)
    default:
        fmt.Println("未知类型")
    }
}
```

### 从接口中提取具体类型

在处理接口类型的变量时，我们可能需要将其转换为具体的类型以便进行进一步的操作。

```go
func processInterface(i interface{}) {
    if s, ok := i.(string); ok {
        fmt.Println("处理字符串:", s)
    } else if n, ok := i.(int); ok {
        fmt.Println("处理整数:", n)
    } else {
        fmt.Println("无法处理的类型")
    }
}
```

## 注意

1. **类型断言只能用于接口类型**：类型断言只能用于接口类型的变量，不能用于非接口类型的变量。
2. **避免 panic**：在使用不返回布尔值的类型断言时，务必确保类型断言不会失败，否则会引发 panic。
3. **类型断言的性能**：类型断言在运行时进行类型检查，因此可能会带来一定的性能开销。在性能敏感的场景中，应谨慎使用。
