# go语言中常见的标准库

1. context 

2. encoding

   - encoding/json 

   - encoding/base64 

   - encoding/hex 

3. errors 

4. flag 

5. fmt 

6. io

   - io 

   - io/util 

7. log 

8. math 

9. net

   - net 

   - net/http 

   - net/url 

10. reflect 

11. regexp 

12. sort 

13. strconv 

14. strings 

15. sync 

16. time

# encoding

```go
import (
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
)

func EncodingCase() {
	type user struct {
		ID   int64
		Name string
		Age  uint8
	}
	u := user{ID: 1, Name: "张三", Age: 18}
	//序列化
	bytes, err := json.Marshal(u)
	fmt.Println(bytes, err)
	u1 := user{}
	//反序列化
	err = json.Unmarshal(bytes, &u1)
	fmt.Println(u1, err)

	//base64编解码
	str := base64.StdEncoding.EncodeToString(bytes)
	fmt.Println(str)
	bytes1, err := base64.StdEncoding.DecodeString(str)
	fmt.Println(bytes1, err)

	//16进制编解码
	str1 := hex.EncodeToString(bytes1)
	fmt.Println(str1)
	bytes2, err := hex.DecodeString(str1)
	fmt.Println(bytes2, err)
}
```

# error

```go
import (
	"errors"
	"fmt"
	"log"
	"time"
)

type cuError struct {
	Code string
	Msg  string
	Time time.Time
}

func (err cuError) Error() string {
	return fmt.Sprintf("code:%s,msg:%s,time:%s", err.Code, err.Msg, err.Time.Format("2006-01-02 15:04:05"))
}
func getErrorCase(code, msg string) error {
	return cuError{
		Code: code,
		Msg:  msg,
		Time: time.Now(),
	}
}

func ErrorsCase() {
	var err error
	err = errors.New("this is a error")
	fmt.Println(err)

	var a, b = -1, -2
	res, err := sum(a, b)
	if err != nil {
		log.Println(res, err)
		cusErr, ok := err.(cuError)
		if ok {
			fmt.Println("cusErr:", cusErr)
		}

	}
}

func sum(a, b int) (int, error) {
	if a <= 0 && b <= 0 {
		return 0, getErrorCase("1001", "参数错误两数求和不能同时小于0")
	}
	return a + b, nil
}
```

# fmt

知道下面这些方法就可以了

```go
import (
	"fmt"
	"os"
)

func FmtCase() {
	//打印到标准输出
	fmt.Println("今天天气很好")
	//格式化，并打印到标准输出
	fmt.Printf("%s天气真好\n", "今天")

	//格式化
	str := fmt.Sprintf("%s今天天气真好", "今天，明天")
	//输出到io.writer
	fmt.Fprint(os.Stderr, str)
}

func FmtCase1() {
	type simple struct {
		value int
	}
	a := simple{
		value: 10,
	}
	//通用占用符
	fmt.Printf("默认格式的值：%v\n", a)
	fmt.Printf("包含字段名称的值：%+v\n", a)
	fmt.Printf("JSON格式的值，go语法表示的值：%#v\n", a)
	fmt.Printf("值的类型：%T\n", a)
	fmt.Printf("输出字面上的百分号：%%10")

	//整数占位符
	v1 := 10
	v2 := 20170
	fmt.Printf("二进制：%b \n", v1)
	fmt.Printf("Unicode码点转字符： %c \n", v2)
	fmt.Printf("八进制：%o \n", v1)
	fmt.Printf("0o八进制：%O  \n", v1)
	fmt.Printf("十进制：%d \n", v1)
	fmt.Printf("十六进制：%x \n", v1)
	fmt.Printf("0x十六进制：%X \n", v1)
	fmt.Printf("十六进制，带0x前缀：%X \n", v1)
	fmt.Printf("用单引号将字符的值包起来： %q \n", v1)
	fmt.Printf("用双引号将字符串的值包起来：%Q \n", v1)

	//宽度设置
	fmt.Printf("宽度为10，默认右对齐，用0填充：%010d \n", v1)
	fmt.Printf("%v的十六进制：%x ; go的语法表示为： %#x ; 指定进制宽度为8，不足8位补0：%08b \n", v1, v1, v1, v1)

}
```

# log

知道下面这些方法就可以了

```go
import (
	"log"
	"os"
)

func init() {
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
	log.SetOutput(os.Stderr)
	//设置log格式
}

func LogCase() {
	var a, b = -1, -2
	_, err := sum(a, b)
	if err != nil {
		log.Println(err)
	}
	log.Printf("a:%d,b:%d,两数求和出现错误:sum: %s \n", a, b, err.Error())
	//log.Fatalf("a:%d,b:%d,两数求和出现错误:sum: %s \n", a, b, err.Error()
	//fatalf函数会输出日志信息并终止程序
}
```

# math

知道下面这些方法就可以了

```go
import (
	"fmt"
	"math"
)

func MathCase() {
	fmt.Println("2的10次方", math.Pow(2, 10))
	fmt.Println("3的平方根", math.Sqrt(9))
	fmt.Println("绝对值", math.Abs(-1))
	fmt.Println("向上取整", math.Ceil(1.2))
	fmt.Println("向下取整", math.Floor(1.2))
	fmt.Println("四舍五入", math.Round(1.2))
	fmt.Println("返回两数中较大的值：", math.Max(1, 2))
	fmt.Println("返回两数中较小的值：", math.Min(1, 2))
	fmt.Println("常量", math.Pi, math.E)
	fmt.Println("90角的正弦值", math.Sin(math.Pi/2))
	fmt.Println("0角的余弦值", math.Cos(0))
	fmt.Println("0角度的正切值", math.Tan(0))
	//fmt.Println("随机数", math/rand.Intn(10))
	fmt.Println("1反正弦值", math.Asin(1))
}
```

# reflect

Go 的反射机制主要通过 `reflect` 包实现，它允许程序在运行时检查类型信息、操作变量值，甚至动态调用方法。

反射的核心是两个类型：

1. `reflect.Type` - 表示 Go 的类型信息
2. `reflect.Value` - 表示 Go 的值信息

### 反射的典型用途

1. 序列化/反序列化（如 JSON、XML 编码解码）
2. ORM 框架实现
3. 函数调用包装器
4. 配置解析
5. 动态类型检查

### 反射的注意事项

1. **性能开销**：反射操作比直接代码调用慢
2. **类型安全**：编译器无法检查反射代码的类型错误
3. **可读性**：反射代码通常较难理解
4. **可设置性**：只有可寻址的值才能被修改（使用 `CanSet()` 检查）

## 案例1

通过这个案例，你可以看到反射如何动态地检查类型信息、操作结构体字段，实现了一个通用的对象复制功能。

```go
func copy(dest interface{}, source interface{}) error {
	sType := reflect.TypeOf(source)  // 获取源对象的类型
	sValue := reflect.ValueOf(source) // 获取源对象的值
	//如果为指针类型则获取其值
	if sType.Kind() == reflect.Ptr {  // 检查是否为指针类型
    	sType = sType.Elem()         
   		sValue = sValue.Elem()      
	}
	dType := reflect.TypeOf(dest)
	dValue := reflect.ValueOf(dest)
	if dType.Kind() != reflect.Ptr {
		return errors.New("目标对象必须为struct指针类型")
	}
	dType = dType.Elem()
	dValue = dValue.Elem()
	if sValue.Kind() != reflect.Struct {
		return errors.New("源对象必须为struct类型或其指针")
	}
	if dValue.Kind() != reflect.Struct {
		return errors.New("目标对象必须为struct类型或其指针")
	}
	destObject := reflect.New(dType)
	for i := 0; i < dType.NumField(); i++ {
		destField := dType.Field(i)
		if sourceField, ok := sType.FieldByName(destField.Name); ok {
			if destField.Type != sourceField.Type {
				continue
			}
			value := sValue.FieldByName(destField.Name)
			destObject.Elem().FieldByName(destField.Name).Set(value)
		}
	}
	dValue.Set(destObject.Elem())
	return nil

}
```

### 1. 获取源对象的类型和值

```go
sType := reflect.TypeOf(source)  // 获取源对象的类型
sValue := reflect.ValueOf(source) // 获取源对象的值
```

`reflect.TypeOf()` 和 `reflect.ValueOf()` 是反射的入口函数，它们分别返回参数的静态类型信息和运行时值信息。

### 2. 处理指针类型

```go
if sType.Kind() == reflect.Ptr {  // 检查是否为指针类型
    sType = sType.Elem()         // 获取指针指向的类型
    sValue = sValue.Elem()       // 获取指针指向的值
}
```

- `Kind()` 方法返回类型的种类（如 Ptr、Struct、Int 等）
- `Elem()` 方法用于获取指针指向的元素类型或值

### 3. 检查目标对象

```go
dType := reflect.TypeOf(dest)
dValue := reflect.ValueOf(dest)
if dType.Kind() != reflect.Ptr {
    return errors.New("目标对象必须为struct指针类型")
}
dType = dType.Elem()  // 获取指针指向的类型
dValue = dValue.Elem() // 获取指针指向的值
```

这里确保目标对象是指针类型，因为我们需要修改它的值。

### 4. 类型验证

```go
if sValue.Kind() != reflect.Struct {
    return errors.New("源对象必须为struct类型或其指针")
}
if dValue.Kind() != reflect.Struct {
    return errors.New("目标对象必须为struct类型或其指针")
}
```

确保源对象和目标对象都是结构体类型（或其指针）。

### 5. 创建目标对象副本

```go
destObject := reflect.New(dType) // 创建指定类型的新指针
```

`reflect.New()` 创建一个指向指定类型的新零值的指针。

### 6. 字段复制

```go
for i := 0; i < dType.NumField(); i++ {
    destField := dType.Field(i) // 获取目标字段信息
    if sourceField, ok := sType.FieldByName(destField.Name); ok {
        if destField.Type != sourceField.Type {
            continue // 类型不匹配则跳过
        }
        value := sValue.FieldByName(destField.Name) // 获取源字段值
        destObject.Elem().FieldByName(destField.Name).Set(value) // 设置目标字段值
    }
}
```

- `NumField()` 返回结构体的字段数量
- `Field(i)` 和 `FieldByName()` 获取字段信息
- `Set()` 方法用于设置值

### 7. 完成复制

```go
dValue.Set(destObject.Elem()) // 将复制结果设置回原目标
```

### 反射使用要点

1. **类型检查**：使用 `Kind()` 检查类型种类
2. **指针处理**：使用 `Elem()` 获取指针指向的内容
3. **值操作**：使用 `Set()` 修改值（必须确保值是可设置的）
4. **结构体操作**：使用 `NumField()`、`Field()` 等方法访问结构体字段

## 案例2

使用 Go 的反射机制从切片中提取指定列的数据

```go
func sliceColum(slice interface{}, column string) interface{} {
	t := reflect.TypeOf(slice)
	v := reflect.ValueOf(slice)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		v = v.Elem()
	}
	if t.Kind() == reflect.Struct {
		val := v.FieldByName(column)
		return val.Interface()
	}
	if t.Kind() != reflect.Slice {
		return nil
	}
	t = t.Elem()
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	f, _ := t.FieldByName(column)
	sliceType := reflect.SliceOf(f.Type)
	//确定切片类型
	s := reflect.MakeSlice(sliceType, 0, 0)
	for i := 0; i < v.Len(); i++ {
		o := v.Index(i)
		if o.Kind() == reflect.Struct {
			val := o.FieldByName(column)
			s = reflect.Append(s, val)
		}
		if o.Kind() == reflect.Ptr {
			v1 := o.Elem()
			val := v1.FieldByName(column)
			s = reflect.Append(s, val)
		}
	}
	return s.Interface()
}
```

### 1. 获取类型和值信息

```go
t := reflect.TypeOf(slice)  // 获取输入的类型信息
v := reflect.ValueOf(slice) // 获取输入的值信息
```

这是反射操作的起点，获取输入参数的类型和值。

### 2. 处理指针类型

```go
if t.Kind() == reflect.Ptr {
    t = t.Elem()  // 获取指针指向的类型
    v = v.Elem()  // 获取指针指向的值
}
```

如果输入是指针，则获取它指向的实际类型和值。

### 3. 处理结构体直接输入

```go
if t.Kind() == reflect.Struct {
    val := v.FieldByName(column)  // 获取指定字段的值
    return val.Interface()        // 将反射值转为接口值返回
}
```

如果输入是结构体而非切片，直接返回指定字段的值。

### 4. 检查输入是否为切片

```go
if t.Kind() != reflect.Slice {
    return nil  // 非切片类型返回nil
}
```

确保后续处理的是切片类型。

### 5. 获取切片元素类型

```go
t = t.Elem()  // 获取切片元素的类型
if t.Kind() == reflect.Ptr {
    t = t.Elem()  // 如果元素是指针，再获取指向的类型
}
```

处理切片元素可能是指针的情况。

### 6. 获取目标字段信息

```go
f, _ := t.FieldByName(column)  // 获取指定字段的信息
sliceType := reflect.SliceOf(f.Type)  // 创建该字段类型的切片类型
```

准备用于存储结果的切片类型。

### 7. 创建结果切片

```go
s := reflect.MakeSlice(sliceType, 0, 0)  // 创建空切片
```

初始化用于存储结果的切片。

### 8. 遍历切片元素

```go
for i := 0; i < v.Len(); i++ {
    o := v.Index(i)  // 获取第i个元素
    // 处理结构体元素
    if o.Kind() == reflect.Struct {
        val := o.FieldByName(column)  // 获取字段值
        s = reflect.Append(s, val)    // 添加到结果切片
    }
    // 处理指针元素
    if o.Kind() == reflect.Ptr {
        v1 := o.Elem()               // 解引用指针
        val := v1.FieldByName(column) // 获取字段值
        s = reflect.Append(s, val)   // 添加到结果切片
    }
}
```

遍历切片中的每个元素，提取指定字段的值并添加到结果切片。

### 9. 返回结果

```go
return s.Interface()  // 将反射值转为接口值返回
```

### 反射关键点总结

1. **类型判断**：使用 `Kind()` 检查类型种类（Ptr、Struct、Slice等）
2. **指针处理**：使用 `Elem()` 获取指针指向的内容
3. **动态创建**：`reflect.SliceOf()` 和 `reflect.MakeSlice()` 动态创建切片
4. **字段访问**：`FieldByName()` 按名称访问结构体字段
5. **值转换**：`Interface()` 将反射值转为普通接口值

## 总代码

```go
import (
	"errors"
	"fmt"
	"reflect"
)

func ReflectCase() {
	type user struct {
		ID    int64
		Name  string
		Age   int
		Hobby []string
	}
	type outUser struct {
		ID    int64
		Name  string
		Age   int
		Hobby []string
	}

	u := user{ID: 1, Name: "张三", Age: 18, Hobby: []string{"篮球", "足球"}}
	out := outUser{}

	res := copy(&out, u)
	fmt.Println(res, out)

	listUser := []user{
		{ID: 1, Name: "张三", Age: 18, Hobby: []string{"篮球", "足球"}},
		{ID: 2, Name: "李四", Age: 19, Hobby: []string{"篮球", "排球"}},
		{ID: 3, Name: "王五", Age: 20, Hobby: []string{"篮球", "羽毛球"}},
	}
	list := sliceColum(listUser, "Hobby")
	fmt.Println(list)
}
```

# regexp

```go
import (
	"fmt"
	"regexp"
)

func RegexpCase() {
	//构建正则表达式对象
	reg := regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
	//判断字符串是否匹配正则表达式
	fmt.Println(reg.MatchString("abc[1234]"))
	//从给定的字符串查找符合条件的字符串
	bytes := reg.FindAll([]byte("efg[456]"), -1) //-1：这是查找的次数限制。-1表示查找所有匹配项，而不仅仅是第一个匹配项。
	fmt.Println(string(bytes[0]))

}
```

# sort

```go
import (
    "fmt"
    "sort"
)

type sortUser struct {
    ID   int64
    Name string
    Age  uint8
}

type ByID []sortUser // 定义一个结构体，实现sort.Interface接口

// 获取长度
func (a ByID) Len() int {
    return len(a)
}

// 交换位置
func (a ByID) Swap(i, j int) {
    a[i], a[j] = a[j], a[i]
}

// 比较大小
func (a ByID) Less(i, j int) bool {
    return a[i].ID < a[j].ID
}

func SortCase() {
    list := []sortUser{
       {1, "Tom", 18},
       {4, "Jerry", 20},
       {3, "Alice", 19},
       {2, "JamYang", 20},
    }
    sort.Slice(list, func(i, j int) bool {
       return list[i].Age < list[j].Age
    })
    fmt.Println(list)

    //实现sort.Interface接口
    sort.Sort(ByID(list))
    fmt.Println(list)

}
```

# sync

为了更好的使用`golang`来进行网络编程，将介绍以下六种除`fmt`外的经典包中的方法及其他内容。共有`sync`,`runtime`,`net`,`reflect`,`io`,`time`包，本系列是学习笔记，只涉及浅显的用法，需要深入了解的可以前往[go语言中文网](https://www.topgoer.com/)以及[Golang标准库文档](https://studygolang.com/pkgdoc)。

首先，我们介绍一下`sync`包，这个包常用的接口如下。

## 进程控制

### `Locker`

这个接口代表一个可以加锁和解锁的对象

```go
type Locker interface {
    Lock()
    Unlock()
}
```

### `sync.WaitGroup`

#### 简要介绍

这个类是用来实现go中并发任务同步的。`sync.WaitGroup`有以下几个方法：

| 方法名                          | 功能                |
| ------------------------------- | ------------------- |
| (wg * WaitGroup) Add(delta int) | 计数器+delta        |
| (wg *WaitGroup) Done()          | 计数器-1            |
| (wg *WaitGroup) Wait()          | 阻塞直到计数器变为0 |

sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过**调用Done()方法将计数器减1**。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。

使用这三个方法时，一般时配套承担一个功能：

1. `defer wg.Done`,这个语句往往放在将要并发的函数的第一行，来确保这个函数并发进程完成之后计数器会减一

2. ```go
    wg.Add(1)
    go work(&wg)
   ```

   add这个方法，往往是在并发语句之前使用，达到计数器增加的效果（在进程结束后由Done方法来减去）

3. `wg.Wait()`,往往放在主进程或者整个进程最后，来确保所有进程执行完之后，才解除阻塞（如果所有的 `Done` 方法都已经调用并且计数器值变为零，`Wait` 方法会立即返回，解除阻塞）

#### 实例

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func work(wg *sync.WaitGroup) {
    defer wg.Done() // 在任务完成后减少等待计数
    fmt.Println("Doing work...")
    time.Sleep(1 * time.Second) // 模拟工作
}

func main() {
    var wg sync.WaitGroup

    // 为每个工作者增加等待计数
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go work(&wg)
    }

    // 等待所有的工作者完成工作
    wg.Wait()
    fmt.Println("All work is done.")
}
```

运行结果：

```
这是一个子进程
这是一个子进程
这是一个子进程
这是一个子进程
这是一个子进程
这是一个主进程
```

#### 为什么使用

```go
func work() {
	fmt.Println("这是一个子进程")
	time.Sleep(1 * time.Second)
}

func main() {

	for i := 0; i < 5; i++ {
		go work()
	}

	fmt.Println("这是一个主进程")
}
```

运行结果：

```go
这是一个子进程
这是一个子进程
这是一个子进程
这是一个主进程
这是一个子进程
这是一个子进程
```

可以看出，如果不使用这个方法进行优化的话，主进程和子进程结束的时间是随机的，优化之后，可以确保主进程在最后完成。

还有人会说，那将主进程结束的语句加一个defer不就好了？而实际情况是，不但没有达到这个效果，这样玩之后，连子进程个数有多少都无法保证了！

```go
func main() {
	defer fmt.Println("这是一个主进程")
	for i := 0; i < 5; i++ {
		go work()
	}

}
```

运行结果：

```
这是一个子进程
这是一个子进程
这是一个主进程
```

#### 补充总结

我们使用`sync.WaitGroup`组合时，一般想要将进程控制在一个个的时间区域内，就像下面代码实现的一样：

```go
func work(wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("这是一个工作的子进程")
	time.Sleep(1 * time.Second)
}

func work2(wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("这是一个摸鱼的子进程")
	time.Sleep(1 * time.Second)
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go work(&wg)
	}
	wg.Wait()
	fmt.Println("偶滴工作结束了")

	var wg2 sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg2.Add(1)
		go work2(&wg2)
	}

	wg2.Wait()
	fmt.Println("呜呜呜，摸鱼结束了")

}
```

运行结果：

```go
这是一个工作的子进程
这是一个工作的子进程
这是一个工作的子进程
这是一个工作的子进程
这是一个工作的子进程
偶滴工作结束了
这是一个摸鱼的子进程
这是一个摸鱼的子进程
这是一个摸鱼的子进程
这是一个摸鱼的子进程
这是一个摸鱼的子进程
呜呜呜，摸鱼结束了
```

### `sync.Cond`

`Cond` 允许 goroutine 在某个条件满足前挂起（等待），并允许其他 goroutine 通知它们条件已经改变，可以继续执行。`Cond` 需要与 `sync.Mutex` 或 `sync.RWMutex` 结合使用来保证条件变量的正确使用。调用 `Wait` 方法的 goroutine 会释放锁并进入等待状态，直到其他 goroutine 调用 `Signal` 或 `Broadcast` 方法来唤醒它们。

#### 方法

1. func NewCond `func NewCond(l Locker) *Cond` 使用锁l创建一个*Cond。*
2. *func (*Cond) Broadcast `func (c *Cond) Broadcast()`Broadcast唤醒所有等待c的线程。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。
3. func (*Cond）`func (c *Cond) Signal()` Signal唤醒等待c的一个线程（如果存在）。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。*
4. *func (*Cond) Wait`func (c *Cond) Wait()` Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。和其他系统不同，Wait除非被Broadcast或者Signal唤醒，不会主动返回。

#### 实例

```go
var (
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)
    ready = false
)

// 线程A
go func() {
    mu.Lock()
    for !ready {
        cond.Wait()
    }
    // 执行任务
    mu.Unlock()
}()

// 线程B
go func() {
    mu.Lock()
    ready = true
    cond.Broadcast()
	//cond.Signal() // 或使用 cond.Broadcast() 唤醒所有等待的 goroutine
    mu.Unlock()
}()
```

运行结果：

```
线程A: 等待条件满足...
线程B: 设置条件为true
线程B: 已经唤醒线程A
线程A: 条件满足，开始执行任务
```

`cond.Wait()` 方法在执行时会自动解除持有的锁，并使当前 goroutine 进入等待状态，具体来说，这个过程包含以下几个步骤：

1. **解除锁**：`cond.Wait()` 方法会自动释放与 `Cond` 关联的 `sync.Mutex` 锁。这样，其他 goroutine 可以获取这个锁，修改条件变量所依赖的状态。
2. **进入等待状态**：在释放锁之后，当前 goroutine 会被挂起（进入等待状态），直到条件满足并被唤醒。
3. **重新获取锁**：当条件被满足并且 `cond.Signal()` 或 `cond.Broadcast()` 被调用后，`cond.Wait()` 会重新获取锁，然后继续执行等待之后的代码。

### `sync.Once`(进阶用法)

`sync.Once` 是一个用来保证某个操作只被执行一次的类型，这在并发编程中非常有用。它可以用来实现线程安全的单例模式或其他只需初始化一次的操作。这个类只含一个方法：

```go
func (o *Once) Do(f func())
```

实例：

```go
package main

import (
	"fmt"
	"sync"
)

var once sync.Once

func initialize() {
	fmt.Println("Initialization")
}

func main() {
	var wg sync.WaitGroup

	// 启动多个 goroutine
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(initialize)
		}()
	}

	// 等待所有 goroutine 完成
	wg.Wait()
}
```

运行结果：

```
Initialization
```

这个方法确保传入的参数（也是一个函数）只会被被执行一次，简洁有效！

### RWNutex（读写锁）

#### 补充——方法总结：

1. func (*RWMutex) Lock `func (rw *RWMutex) Lock()`Lock方法将rw锁定为写入状态，禁止其他线程读取或者写入。*
2. *func (*RWMutex) Unlock `func (rw *RWMutex) Unlock()` Unlock方法解除rw的写入锁状态，如果m未加写入锁会导致运行时错误。
3. func (*RWMutex) RLock `func (rw *RWMutex) RLock()` RLock方法将rw锁定为读取状态，禁止其他线程写入，但不禁止读取。*
4. *func (*RWMutex) RUnlock `func (rw *RWMutex) RUnlock()`Runlock方法解除rw的读取锁状态，如果m未加读取锁会导致运行时错误。
5. func (*RWMutex) RLocker `func (rw *RWMutex) RLocker() Locker` Rlocker方法返回一个互斥锁，通过调用rw.Rlock和rw.Runlock实现了Locker接口。

## 共用存储

### `sync.Pool`

Pool是一个可以分别存取的临时对象的集合。Pool中保存的任何item都可能随时不做通告的释放掉。如果Pool持有该对象的唯一引用，这个item就可能被回收。**Pool可以安全的被多个线程同时使用**。Pool的目的是缓存申请但未使用的item用于之后的重用，以减轻GC的压力。也就是说，让创建高效而线程安全的空闲列表更容易。但Pool并不适用于所有空闲列表。**Pool的合理用法是用于管理一组静静的被多个独立并发线程共享并可能重用的临时item**。Pool提供了让多个线程分摊内存申请消耗的方法。Pool的一个好例子在fmt包里。该Pool维护一个动态大小的临时输出缓存仓库。该仓库会在过载（许多线程活跃的打印时）增大，在沉寂时缩小。另一方面，管理着短寿命对象的空闲列表不适合使用Pool，因为这种情况下内存申请消耗不能很好的分配。这时应该由这些对象自己实现空闲列表。

创建Pool常使用的方法：

```go
var pool = sync.Pool{
	New: func() interface{} {
		// 这里定义池中对象的创建方式
		return &MyObject{}
	},
}
```

#### 方法

1. func (*Pool) Get `func (p *Pool) Get() interface{}` Get方法从池中选择任意一个item，删除其在池中的引用计数，并提供给调用者。Get方法也可能选择无视内存池，将其当作空的。调用者不应认为Get的返回这和传递给Put的值之间有任何关系。假使Get方法没有取得item：如p.New非nil，Get返回调用p.New的结果；否则返回nil。*
2. *func (*Pool) Put `func (p *Pool) Put(x interface{})` Put方法将x放入池中。

#### 实例

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// 创建一个 sync.Pool 实例
var pool = sync.Pool{
	New: func() interface{} {
		// 这里定义池中对象的创建方式
		return &MyObject{}
	},
}

type MyObject struct {
	ID    int
	Value string
}

func main() {
	var wg sync.WaitGroup

	// 启动多个 goroutine
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(goroutineID int) {
			defer wg.Done()

			// 从池中获取一个对象
			obj := pool.Get().(*MyObject)
			obj.ID = goroutineID
			obj.Value = fmt.Sprintf("Value for ID %d", goroutineID)
			fmt.Printf("Goroutine %d got object with ID: %d and Value: %s\n", goroutineID, obj.ID, obj.Value)

			// 模拟处理对象的时间
			time.Sleep(time.Millisecond * 500)

			// 进行处理：增加一些变更
			obj.Value = fmt.Sprintf("Processed Value for ID %d", goroutineID)
			fmt.Printf("Goroutine %d processed object with ID: %d to Value: %s\n", goroutineID, obj.ID, obj.Value)

			// 放回池中
			pool.Put(obj)
			fmt.Printf("Goroutine %d put object with ID: %d back to pool\n", goroutineID, obj.ID)
		}(i)
	}

	// 等待所有 goroutine 完成
	wg.Wait()
}
```

1. **增加 `Value` 字段**：`MyObject` 结构体现在有一个 `Value` 字段，用于存储字符串数据。
2. **获取对象**：每个 goroutine 从 `sync.Pool` 中获取一个 `MyObject` 实例，并设置其 `ID` 和 `Value` 字段。
3. **处理对象数据**：每个 goroutine 模拟对对象的处理，这里我们改变 `Value` 字段的内容以反映处理过程。
4. **放回对象**：处理完对象后，每个 goroutine 将对象放回池中，供其他 goroutine 重用。

运行结果：

```
Goroutine 3 got object with ID: 3 and Value: Value for ID 3
Goroutine 4 got object with ID: 4 and Value: Value for ID 4
Goroutine 0 got object with ID: 0 and Value: Value for ID 0
Goroutine 1 got object with ID: 1 and Value: Value for ID 1
Goroutine 2 got object with ID: 2 and Value: Value for ID 2
Goroutine 0 processed object with ID: 0 to Value: Processed Value for ID 0
Goroutine 0 put object with ID: 0 back to pool
Goroutine 2 processed object with ID: 2 to Value: Processed Value for ID 2
Goroutine 1 processed object with ID: 1 to Value: Processed Value for ID 1
Goroutine 1 put object with ID: 1 back to pool
Goroutine 3 processed object with ID: 3 to Value: Processed Value for ID 3
Goroutine 3 put object with ID: 3 back to pool
Goroutine 4 processed object with ID: 4 to Value: Processed Value for ID 4
Goroutine 4 put object with ID: 4 back to pool
Goroutine 2 put object with ID: 2 back to pool
```

相当于创建一个共享数据池，以供一个进程中的多个go程使用。

### `sync.Map`

Go语言中内置的map不是并发安全的,因此我们使用sync包中的Map。简而言之：`sync.Map`是一个并发版本的`Go`语言的`map`，`sync.Map` 的一些主要操作：

- `Load(key interface{}) (interface{}, bool)`：通过键值查找映射中的值，如果没有找到，则返回零值和布尔类型的false。
- `Store(key, value interface{})`：将键值对存入映射。如果键已经在映射中，则新的值会替换旧的值。
- `Delete(key interface{})`：从映射中删除与给定键关联的值。
- `Reserve`：在并发场景中，定义了如何预分配映射的存储空间，能够提高性能。可以使用 `sync.Map.LoadOrStore(key, value)`：如果键已经在映射中，返回映射中的值；否则，将新值存入映射并返回它。