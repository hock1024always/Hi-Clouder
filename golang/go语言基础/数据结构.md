# Map

1. Map 是一种**无序**的键值对的集合，最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值
2. 我们可以像迭代数组和切片那样迭代Map，但Map是无序的，遍历 Map 时返回的键值对的顺序是不确定的
3. 获取 Map 的值时，如果键不存在，返回该类型的零值
4. Map 是**引用类型**，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都**指向**同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量

## 定义与使用

### 创建

1. **使用`make`关键字创建:** `map_variable := make(map[KeyType]ValueType, initialCapacity)`

2. **使用字面量创建:** 

   ```go
   m := map[string]int{
       "apple": 1,
       "banana": 2,
       "orange": 3,
   }
   ```

### 插入值

直接赋值即可

```go
siteMap [ "Google" ] = "谷歌"
```

### 获取值

```go
// 获取键值对
v1 := m["apple"]
v2, ok := m["pear"]  // 如果键不存在，ok 的值为 false，v2 的值为该类型的零值
```

### 修改键值对

```go
m["apple"] = 5
```

### 获取Map长度

```go
len := len(m)
```

### 遍历Map

```go
for k, v := range m {
    fmt.Printf("key=%s, value=%d\n", k, v)
}
```

### 删除键值对

注意是整个键值对删除，而不是将值删除

```go
delete(m, "banana")
```

# 切片

1. Go 语言切片是对数组的抽象，可以理解为动态数组
2. 可以理解切片是一个数字的截取，而切片的容量指的是其底层数组的大小

## 定义与初始化

1. **数组形式声明：**`var identifier []type`

2. **`make`方式声明:** `var slice1 []type = make([]type, len, capacity)`(capacity为可选参数)

   如果是不写capacity，则`len`即**为切片长度也为切片容量**

### 初始化切片

#### 直接初始化

`s :=[] int {1,2,3 } `,**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 **1,2,3**，其 **cap=len=3**

#### 借助数组初始化

1. `s :=[] int {1,2,3}` 直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 **1,2,3**，其 **cap=len=3**。
2. `s := arr[:]` 初始化切片 **s**，是数组 arr 的引用。
3. `s := arr[startIndex:endIndex]` 将 arr 中从**下标 startIndex 到 endIndex-1** 下的元素创建为一个新的切片。
4. `s := arr[startIndex:]`默认 endIndex 时将表示一直到arr的最后一个元素。
5. `s := arr[:endIndex]` 默认 startIndex 时将表示从 arr 的第一个元素开始。
6. `s1 := s[startIndex:endIndex]` 通过切片 s 初始化切片 s1。
7. `s :=make([]int,len,cap)` 通过内置函数 **make()** 初始化切片**s**，**[]int** 标识为其元素类型为 int 的切片,并且有指定的容量。

### 空切片

一个切片在未初始化之前默认为 nil，长度为 0，容量为0

```go
func main() {
   var numbers []int

   printSlice(numbers)

   if(numbers == nil){
      fmt.Printf("切片是空的")
   }
}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
```

## 切片方法

1. `len(x)` 返回切片长度
2. `cap(x)` 返回切片容量
3. `numbers = append(numbers, 0)` 追加元素到切片的末尾，允许追加空切片
4. `copy(numbers1,numbers)` 把后面切片中的内容拷贝到前面切片中，放在开头

```go
func main() {
	var numbers []int
	printSlice(numbers)

	/* 允许追加空切片 */
	numbers = append(numbers, 0)
	printSlice(numbers)

	/* 向切片添加一个元素 */
	numbers = append(numbers, 1)
	printSlice(numbers)

	/* 同时添加多个元素 */
	numbers = append(numbers, 2, 3, 4)
	printSlice(numbers)

	/* 创建切片 numbers1 是之前切片的两倍容量*/
	numbers1 := make([]int, len(numbers), (cap(numbers))*2)

	/* 拷贝 numbers 的内容到 numbers1 */
	numbers1 = append(numbers1, 7)
	copy(numbers1, numbers)
	printSlice(numbers1)
}

func printSlice(x []int) {
	fmt.Printf("len=%d cap=%d slice=%v\n", len(x), cap(x), x)
}
```

返回的numbers1种的内容是`[0 1 2 3 4 7]`

## 切片截取

可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*

1. 包含前序号位置，**不包含**后序号位置
2. 序号和数组一致，即从0开始

```go
func main() {
   /* 创建切片 */
   numbers := []int{0,1,2,3,4,5,6,7,8}  
   printSlice(numbers)

   /* 打印原始切片 */
   fmt.Println("numbers ==", numbers)

   /* 打印子切片从索引1(包含) 到索引4(不包含)*/
   fmt.Println("numbers[1:4] ==", numbers[1:4])

   /* 默认下限为 0*/
   fmt.Println("numbers[:3] ==", numbers[:3])

   /* 默认上限为 len(s)*/
   fmt.Println("numbers[4:] ==", numbers[4:])

   numbers1 := make([]int,0,5)
   printSlice(numbers1)

   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */
   number2 := numbers[:2]
   printSlice(number2)

   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */
   number3 := numbers[2:5]
   printSlice(number3)

}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
```

# Range

 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素

## 数组、切片和Map

```go
// 完全读取键值对
for key, value := range oldMap {
    newMap[key] = value
}
// 只读取一个 
for key := range oldMap
for _, value := range oldMap
```

## 字符串

```go
for i, c := range "hello" {
        fmt.Printf("index: %d, char: %c\n", i, c)
    }
```

## 通道（Channel）

range 遍历从通道接收的值，直到通道关闭

```go
func main() {
    ch := make(chan int, 2)
    ch <- 1
    ch <- 2
    close(ch)
   
    for v := range ch {
        fmt.Println(v)
    }
}
```

# 正则表达式

了解了解就行

Go 语言中，正则表达式通过 `regexp` 包来实现。正则表达式通过定义一种模式（pattern），可以快速搜索、替换或提取符合该模式的字符串`regexp` 包中常用的函数和方法：

1. **`Compile` 和 `MustCompile`**：用于编译正则表达式。`Compile` 返回一个 `*Regexp` 对象和一个错误，而 `MustCompile` 在编译失败时会直接 panic。
2. **`MatchString`**：检查字符串是否匹配正则表达式。
3. **`FindString` 和 `FindAllString`**：用于查找匹配的字符串。`FindString` 返回第一个匹配项，`FindAllString` 返回所有匹配项。
4. **`ReplaceAllString`**：用于替换匹配的字符串。
5. **`Split`**：根据正则表达式分割字符串。

## 基本语法

- `.`：匹配任意单个字符（除了换行符）。
- `*`：匹配前面的字符 0 次或多次。
- `+`：匹配前面的字符 1 次或多次。
- `?`：匹配前面的字符 0 次或 1 次。
- `\d`：匹配数字字符（等价于 `[0-9]`）。
- `\w`：匹配字母、数字或下划线（等价于 `[a-zA-Z0-9_]`）。
- `\s`：匹配空白字符（包括空格、制表符、换行符等）。
- `[]`：匹配括号内的任意一个字符（例如 `[abc]` 匹配 `a`、`b` 或 `c`）。
- `^`：匹配字符串的开头。
- `$`：匹配字符串的结尾。

## 示例

### 检查字符串是否匹配正则表达式

```go
package main

import (
  "fmt"
  "regexp"
)

func main() {
  pattern := `^[a-zA-Z0-9]+$`
  regex := regexp.MustCompile(pattern)

  str := "Hello123"
  **if** regex.MatchString(str) {
    fmt.Println("字符串匹配正则表达式")
  } **else** {
    fmt.Println("字符串不匹配正则表达式")
  }
}
```

### 查找匹配的字符串

```go
package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := `\d+`
    regex := regexp.MustCompile(pattern)

    str := "我有 3 个苹果和 5 个香蕉"
    matches := regex.FindAllString(str, -1)
    fmt.Println("找到的数字：", matches)
}
```

### 替换匹配的字符串

```go
package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := `\s+`
    regex := regexp.MustCompile(pattern)

    str := "Hello    World"
    result := regex.ReplaceAllString(str, " ")
    fmt.Println("替换后的字符串：", result)
}
```

### 分割字符串

```go
package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := `,`
    regex := regexp.MustCompile(pattern)

    str := "apple,banana,orange"
    parts := regex.Split(str, -1)
    fmt.Println("分割后的字符串：", parts)
}
```

## 注意事项

1. **性能问题**:正则表达式的匹配和替换操作可能会消耗较多资源，尤其是在处理大量数据时。建议在性能敏感的场景下谨慎使用。
2. **转义字符**:在 Go 语言中，正则表达式中的反斜杠 `\` 需要写成 `\\`，因为反斜杠在字符串中也是转义字符。
3. **错误处理**:使用 `Compile` 函数时，务必检查返回的错误，以避免程序崩溃。

# 类型转换

基本格式：`type_name(expression)`

## 数值型类型转换

```go
var a int = 10
var b float64 = float64(a)
```

## 字符串类型转换

**字符串转为整形**

```go
num, _ = strconv.Atoi(str)
```

**整形转化为字符串**

```go
str := strconv.Itoa(num)
```

**浮点数转换为字符串**

```go
str := strconv.FormatFloat(num, 'f', 2, 64)
```

